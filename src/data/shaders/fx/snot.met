//new

using engineflags;
using settemplates;
using tmu;

template
{
    public string TemplateCategory() { return "Objects FX"; }

    category Main
    {
        class Textures
        {
            string_dat clr_0_tex = "" : editor(ImageFileNameEditor), display(Projection texture);
            string_dat msk_0_tex = "" : editor(ImageFileNameEditor), display(Mask texture);
        }	
    }

    templatebody()
    {
		platform("*", "none; instancing");

        tech("opq2")
        {
            Cull(NONE);
            DepthFunc(LEQUAL, TRUE);
            Input I_POS_MS = new InputFloat4("POSITION");
            Input I_CLR_USR = new InputFloat4("COLOR_USER");			

            X_BIAS = SetTexcoord("FLOAT");

			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");
			Output O_NRM = new OutputFLOAT4("COLOR2");

            S_CLR_0 = SetTexture2D(clr_0_tex, LINEAR_MIP_LINEAR, MIRROR, MIRROR, FALSE);
            X_UV_0 = SetTexcoord2("FLOAT");
            X_NRM_ES = SetTexcoord3("FLOAT");

            VertexShader()
            {
                hlsl()
                {
                    #include <common.hlsl>
                    #include <master_new.hlsl>

                    void main()
                    {
                        float4 inv_model_xfm[3];
                        InvertMTX(MODEL_XFORM_4x3, inv_model_xfm);

                        float4 usr_0 = Decode_Usr(I_CLR_USR);

                        X_BIAS = 256.0/255.0 - usr_0.w;
                        
                        I_POS_MS = Decode_Pos(I_POS_MS);
                        float4 pos_ms = I_POS_MS;
                        pos_ms.y *= usr_0.y;
                        X_UV_0 = pos_ms.xy * float2(1.0, -2.0) + float2(0.0, 1.0);
                        
                        float2 cam_pos_2d_ms = Mul_Pos(CAMERA_POS_WS, inv_model_xfm).xz;
                        float2 cam_dir_n_2d_ms = normalize(-cam_pos_2d_ms);
                        
                        float2 offset_dir = cam_dir_n_2d_ms.yx * I_POS_MS.x;
                        pos_ms.xz = offset_dir * float2(-1.0, 1.0);

                        float2 nrm_2d_ms = pos_ms.xz * 0.25 - cam_dir_n_2d_ms;
                        float3 nrm_ms = float3(nrm_2d_ms.x, 0.0, nrm_2d_ms.y);
                        float3 nrm_ws = Mul33(nrm_ms, MODEL_XFORM_4x3);
                        X_NRM_ES = Mul33(nrm_ws, VIEW_XFORM);
                        
                        float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
                        V_POS_OUT_TC = Pos_Out_WS(pos_ws);
                    }
                }

            }

            PixelShader()
            {
                hlsl()
                {
 					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

                    #include <master_new.hlsl>
					#include <colorops.hlsl>
					#include <gamma.hlsl>

                    void main()
                    {
                        O_SPC = Sample(S_CLR_0, X_UV_0);
                        FLOAT bias = O_SPC.w - X_BIAS;
                        clip (bias);
						O_DIF = O_SPC;
						O_SPC.xyz = SwizzleXXX( Linear2Gamma(Luminance(O_SPC.xyz) * 0.5) );
                        O_SPC.w = 0.0;
                        FLOAT3 nrm_cs = normalize(X_NRM_ES);
                        nrm_cs.xy += (O_SPC.w * 2.0 - 1.0) * 0.25;
                        nrm_cs.z *= bias * 0.75 + 0.25;
                        nrm_cs = nrm_cs * 0.5 + 0.5;
                        O_NRM = FLOAT4(nrm_cs, 1.0);
                    }
                }
            }
        }
    }
}

  
