//new

using engineflags;
using settemplates;
using tmu;

template
{
	category Main
	{
		string_dat s_base_tex = s_tex_def;
		string_dat s_opacity_tex = s_tex_def;
		float_dat f_speed = 2.0;
		float_dat f_waves = 1.0;
		float_dat f_intensity = 4.0;
	}

    templatebody()
    {
		platform("*", "none; instancing");

		tech(s_tech_trn)
        {

			Cull(CW);

			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, ZERO, ONE);
			DepthFunc(LEQUAL, FALSE);

			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_NRM_MS = new InputFloat3("NORMAL0");

			Output O_CLR = new OutputFLOAT4("COLOR0");

			X_UV_0 = SetTexcoord2();
			X_UV_1 = SetTexcoord2();
			X_UV_2 = SetTexcoord2();
			X_UV_ENV = SetTexcoord3();
			X_CAM_DIR = SetTexcoord3();
			X_CLR_0 = SetTexcoord4();

			S_CLR = SetTexture(s_base_tex);
			S_OPACITY = SetTexture(s_opacity_tex);
			S_RFR = SetTexture(15, LINEAR_NO_MIP, WRAP, WRAP, false);

			extern float_dat f_pp_hdr_intensity_emissive;
            extern float_dat TIME;

			C_SPEED = SetConst(f_speed);
			C_SPEED_2 = SetConst(1.5 * f_speed);
			C_INTENSITY = SetConst(f_pp_hdr_intensity_emissive * f_intensity);
			C_WAVES = SetConst(50.0 * f_waves);

			C_TIME_0 = SetConst(TIME / f_speed);
			C_TIME_1 = SetConst(TIME / (1.5 * f_speed));
			C_SIN_ADD = SetConst(f_speed * TIME);

			extern vec3_dat v_pp_sun_scattering_dir;
			C_SUN_SCATTERING_DIR = SetConst(v_pp_sun_scattering_dir);

			VertexShader()
			{
				hlsl(s_hlsl_profile_def)
				{

					#include <master_new.hlsl>

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_MS);
						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM);

						X_UV_0 =  Decode_UV(I_UV_0);

						pos_ws.xz += C_WAVES * (1.0 - X_UV_0.yy) * sin( C_SIN_ADD + (pos_ms.xz + pos_ms.yy) * C_SPEED);

						X_CLR_0.rgb = Gamma_Decode(CONST_0.rgb);
						X_CLR_0.a = 1.0;

						V_POS_OUT_TC = Mul44(pos_ws, VIEWPROJ_XFORM);

						X_UV_1 = X_UV_0;
						X_UV_2 = X_UV_0;

						X_UV_1.y *= 2.0;
						X_UV_1.x *= -1.0;
						X_UV_2.y *= 2.0;

						X_UV_1.y -= C_TIME_0;
						X_UV_2.y -= C_TIME_1;

						float3 v_cam_dir_ws = pos_ws.xyz - CAMERA_POS_WS.xyz;
						float3 v_cam_dir_n_ws = normalize(v_cam_dir_ws);

						float3 v_nrm_ws = Mul33(I_NRM_MS.xyz, MODEL_XFORM);
						v_nrm_ws = normalize(v_nrm_ws);

						X_UV_ENV = reflect(v_cam_dir_n_ws, v_nrm_ws) - 1.0;

						X_CAM_DIR = CAMERA_POS_WS.xyz - pos_ws.xyz;
					}
				}

			}

			PixelShader()
			{
				hlsl(s_hlsl_profile_def)
				{
					#include <master_new.hlsl>
					#include <fog.hlsl>

					void main()
					{
						FLOAT v_clr_0 = Sample_h2( S_CLR, X_UV_2 ).g;
						FLOAT v_clr_1 = Sample_h2( S_CLR, X_UV_1 ).g;
						FLOAT f_mask  = Sample_h4(S_OPACITY, X_UV_0).a;
						FLOAT f_noise  = Sample_h2(S_OPACITY, 3 * X_UV_1).g + Sample_h2(S_OPACITY, 3 * X_UV_2).g;

						float waves = (1.3 - X_UV_0.y) * (v_clr_0 + v_clr_1);

						f_mask *= f_mask * waves * 2.0;

						float3 v_uv_env = X_UV_ENV;
						v_uv_env.xyz += f_noise;

						float3 env = Sample_f3(S_RFR, v_uv_env.rg);

						float4 v_out;
						v_out.rgb = 0.7 * lerp( SwizzleXXX(waves), env, env) + 0.5 * env;
						v_out.rgb *= v_out.rgb * X_CLR_0.rgb;
						v_out.a = saturate(f_mask);

						O_CLR.xyz = ScatteringApply( normalize(-X_CAM_DIR), C_SUN_SCATTERING_DIR, length(X_CAM_DIR), v_out.xyz);
						O_CLR.a = v_out.a;


						clip(-step(O_CLR.a, 0.001));

					}
				}
			}
        }
    }
}
