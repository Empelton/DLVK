//new

using engineflags;
using settemplates;
using standard_opq;
using attribs;

template
{
	public string TemplateCategory() { return "Objects"; }	
	
	category Basic
	{
		class Main
		{
			string_dat clr_tex = "" : editor(ImageFileNameEditor), display(Base color texture);
			bool_dat clip_on = FALSE : display(Alphatest enabled);
			bool_dat cast_shadows = FALSE : display(Cast Shadows enabled);
			
		}
		class Animation
		{
			bool_dat flag_animation = FALSE : display(Flag Animation);
			bool_dat animation_vs = FALSE : display(Flag Animation);
			string_dat clr_tex_vrt = "" : editor(ImageFileNameEditor), display(Animation texture);
			string_dat clr_nrm = "" : editor(ImageFileNameEditor), display(nrm texture);
			float_dat f_nrm_scale = 1.0 : display(nrm scale);
			float_dat flag_speed_factor = 1.0 : display(Speed);
			float_dat flag_dist_size = 0.10 : display(Scale);
			float_dat flag_dist_factor = 1.0 : display(Distorsion);
			
		}
	}

    category Advanced
    {
        class Geometry
        {
            bool_dat static_on = true;
        }
    }
	
	templatebody()
	{
		platform("*", "none; instancing");

		tech("opq")
		{   
			extern float_dat TIME;
			extern float_dat f_pp_wind_offset;
			Cull(NONE);
			DepthFunc(LEQUAL, TRUE);
			AddLine("StencilMarker();");
			
			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_NRM_0 = new InputFloat3("NORMAL0");
			
			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");
			Output O_NRM = new OutputFLOAT4("COLOR2");
			
			X_UV_0 = SetTexcoord2("FLOAT");
			X_NRM = SetTexcoord3();
			X_BNR = __none;	
			X_TNG = __none;
			Define("D_DIST", flag_dist_factor);
			Define("D_SCALE", flag_dist_size);
			C_TIME_0 = SetConst(flag_speed_factor * f_pp_wind_offset);
			
			if(flag_animation)
			{
				Define("D_ANIMATION_ON",1);
				Input I_TNG_0 = new InputFloat4("TANGENT");			

				S_CLR_VRT = SetVSTexture2D(clr_tex_vrt,NO_FILTERING, WRAP,WRAP,FALSE);
				S_NRM = SetTexture(clr_nrm);
				
				X_UV_1 = SetTexcoord2("FLOAT");
				X_BNR = SetTexcoord3();					
				X_TNG = SetTexcoord3();	
				X_MSK = SetTexcoord();					

				C_NRM_SCALE = SetConst(f_nrm_scale);
			}
			
			if(clr_tex != "") 
			{	
				S_CLR = SetTexture(clr_tex);
			}
			
			if(clip_on)
			{
				Define("D_CLIP_ON", 1);
			}			
			if(animation_vs)
			{
				Define("D_ANIM_VS", 1);
				C_SPEED_FACTOR_F0 = SetConst(flag_speed_factor * f_pp_wind_offset * 10 );
				C_SPEED_FACTOR_F1 = SetConst(flag_speed_factor * f_pp_wind_offset* 0.85  *10);
				C_SPEED_FACTOR_F2 = SetConst(flag_speed_factor * f_pp_wind_offset* 1.3 *10 );
				C_SPEED_FACTOR_F3 = SetConst(flag_speed_factor * f_pp_wind_offset* 0.5*10 );
				C_SPEED_FACTOR_F4 = SetConst(f_pp_wind_offset * 2.0 * flag_speed_factor*10 );
				
				Define("D_DIST_FACTOR_F0", flag_dist_factor);
				Define("D_DIST_FACTOR_F1",  flag_dist_factor * 2.0);
				Define("D_DIST_FACTOR_F2", flag_dist_factor * 0.7);
				Define("D_DIST_FACTOR_F3", flag_dist_factor* 6.3 );

				Define("D_DIST_SIZE_F0", flag_dist_size*50);
				Define("D_DIST_SIZE_F1", flag_dist_size*0.45*50);
				Define("D_DIST_SIZE_F2", flag_dist_size * 0.5*50);
				Define("D_DIST_SIZE_F3", flag_dist_size * 0.9 *50);
				Define("D_DIST_SIZE_F4", flag_dist_size * 1.1*50);
			}
			
			VertexShader() 
			{
				use Instancing();
				
				hlsl()
				{
					
					#include <master_new.hlsl>
					CONST_FLOAT f_wind_power;
					CONST_FLOAT f_pp_wind_noise;
					CONST_FLOAT4 v_pp_wind_2d_xform;

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_MS);
						X_UV_0 = Decode_UV(I_UV_0);
						
						#if defined(D_ANIMATION_ON)
							
							float msk_0 = (1 - 1/(pos_ms.x + 1)) *D_DIST ;
							float wind_power_msk = saturate(f_pp_wind_noise * f_wind_power);
							X_MSK = msk_0 * wind_power_msk;
							float3 pivot_ws = float3(MODEL_XFORM_4x3[0].w, MODEL_XFORM_4x3[1].w, MODEL_XFORM_4x3[2].w);
							float3 wind_direction_vec_ws = lerp(float3(0.0,-1.0, 0.0), v_pp_wind_2d_xform.xwy, wind_power_msk ); // t0			
							float3 wind_direction_vec_ms = normalize(Mul33T(wind_direction_vec_ws,MODEL_XFORM_4x3 )); // t0							
							
							float3 pos_new_ms = SwizzleXXX(0.0);
							pos_new_ms = wind_direction_vec_ms * pos_ms.x ;
							pos_new_ms.y += pos_ms.y;
							 
							float delta_t = dot(pivot_ws, SwizzleXXX(1.0));
								X_UV_1 = X_UV_0 * D_SCALE - float2( C_TIME_0*0.5 + delta_t, C_TIME_0*0.01);
							#if defined (D_ANIM_VS)
								float pos_y_f1 = ( sin ( C_SPEED_FACTOR_F0 - pos_ms.x * D_DIST_SIZE_F0 + pos_ms.y * D_DIST_SIZE_F1 + delta_t * 14.782 ) * D_DIST_FACTOR_F2 ) ;
								float pos_y_f2 = ( sin ( C_SPEED_FACTOR_F2 + pos_ms.y * D_DIST_SIZE_F1 + delta_t * 85.351 )) ;
								float pos_y_f3 = ( sin ( C_SPEED_FACTOR_F3 - pos_ms.x *  D_DIST_SIZE_F2 + delta_t * 125.5346 ))  ;
								float pos_x_f1 = (( sin( C_SPEED_FACTOR_F1 - pos_ms.x * D_DIST_SIZE_F3 + pos_ms.y * D_DIST_FACTOR_F1 - delta_t * 2.0 ) - 0.5 )  ) ;
								float pos_z_f1 = (( sin ( C_SPEED_FACTOR_F2 - pos_ms.x * D_DIST_SIZE_F4 + pos_ms.y * D_DIST_FACTOR_F3 - delta_t * 2.0 ) - 0.5 )  ) ;
								
								float3 noise_vec = float3( pos_x_f1 +pos_z_f1  ,(pos_y_f1*pos_y_f2+pos_y_f3) , pos_z_f1*pos_y_f1 ) * D_DIST_FACTOR_F0 *0.4;
								#else
								float3 noise_vec = Sample(S_CLR_VRT,  X_UV_1,  0).xyz;
								noise_vec = noise_vec * 2.0 - 1.0;
								noise_vec.y *= (-1.0);
							#endif
							pos_ms.xyz = pos_new_ms ;
							
							float2 noise_dir_space;
							noise_dir_space.x = dot(noise_vec.zx, wind_direction_vec_ms.xz * float2(1,-1));
							noise_dir_space.y = dot(noise_vec.zx, wind_direction_vec_ms.zx);
							float3 noise_vec_new;
							noise_vec_new.xz = noise_dir_space;
							noise_vec_new.y = noise_vec.y;

							pos_ms.xyz += noise_vec_new * X_MSK ;
							
						#endif
						
						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);				
					
						
						#if defined (D_ANIMATION_ON)
							float3 tng_ws = wind_direction_vec_ws ; //
							float3 tng_es = Mul33(tng_ws, VIEW_XFORM); //
							float3 tng_n_es = normalize(tng_es);
							X_TNG = tng_n_es; 
							float3 bnr_ms = float3( 0.0,1.0,0.0);
							float3 bnr_ws = Mul33(bnr_ms, MODEL_XFORM_4x3);
							float3 bnr_es = Mul33(bnr_ws, VIEW_XFORM);
							float3 bnr_n_es = normalize(bnr_es);
							X_BNR = bnr_n_es; 
							X_NRM = cross(bnr_n_es, tng_n_es); //
						#else
							float3 nrm_ws = Mul33(I_NRM_0, MODEL_XFORM_4x3);
							float3 nrm_es = Mul33(nrm_ws, VIEW_XFORM);
							float3 nrm_n_es = normalize(nrm_es);
							X_NRM = nrm_n_es;			
							
						#endif						

					}
				}
			}
		
		PixelShader()
			{
				hlsl()
				{
					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif
					
					#include <master_new.hlsl>											
					
					void main()
					{
						#if defined(S_CLR)
							O_DIF = Sample(S_CLR, X_UV_0);
							#if defined(D_CLIP_ON)
								clip(O_DIF.w -0.25);
							#endif
							O_DIF.w = saturate(O_DIF.w * 2.0 - 1.0);
						#else
							O_DIF = FLOAT4(1.0, 0.1, 0.5, 0.0);
						#endif

						#if defined(D_ANIMATION_ON)
							FLOAT3 nrm = SwizzleXXX(1.0);
							FLOAT3 M_ES2TS[3];
							M_ES2TS[0] = X_TNG;
							M_ES2TS[1] = X_BNR;
							M_ES2TS[2] = X_NRM;
							nrm.xy = Sample(S_NRM, X_UV_1).ag * 2.0 - 1.0;
							nrm.xy *= C_NRM_SCALE * X_MSK;
							FLOAT3 nrm_es = Mul33T(nrm, M_ES2TS);
						#else
							FLOAT3 nrm_es = X_NRM;
						#endif
						
						O_NRM.xyz = nrm_es * 0.5 + 0.5;
						O_NRM.w = 1.0;											
						O_SPC = O_DIF * float4(0.0, 0.0, 0.0, 1.0);
					}
				}
			}
		}
	}
}