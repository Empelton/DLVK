//new

using engineflags;
using settemplates;

template
{
	category Main
	{
		class Basic
		{
			string_dat clr_tex = s_tex_def : editor(ImageFileNameEditor), display(Color);
		}
		class Flock
		{
			float_dat bird_scale = 0.3 : editor(FloatSpinEditor), display(Skala ptaka);
			float_dat rozut_scale = 5.0 : editor(FloatSpinEditor), display(Skala rozota stada);
			float_dat rozut_x = 1.0 : editor(FloatSpinEditor), display(Rozot stada x);
			float_dat rozut_y = 1.0 : editor(FloatSpinEditor), display(Rozot stada y);
			float_dat rozut_z = 1.0 : editor(FloatSpinEditor), display(Rozot stada z);
			float_dat wings_speed = 30.0 : editor(FloatSpinEditor), display(Majtanie zkszyszlami prendkozc);
			float_dat fly_speed = 0.5: editor(FloatSpinEditor), display(Frowanie prenkozc);
			float_dat fly_fac = 0.5 : editor(FloatSpinEditor), display(Frowanie rozut);
			float_dat zur_zur = 0.0 : editor(FloatSpinEditor), display(bardziej rzoraf);

		}
	}

	templatebody()
	{
		tech("opq2")
		{
			use SetupMaterial();
			Cull(NONE);
			DepthFunc(LEQUAL, TRUE);
			Input I_POS_0 = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_UV_1 = new InputFloat2("TEXCOORD1");
			Input I_NRM_0 = new InputFloat3("NORMAL0");
			Input I_VCLR = new InputFloat4("COLOR");
			Input I_CLR_USR = new InputFloat4("COLOR_USER");

			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");
			Output O_NRM = new OutputFLOAT4("COLOR2");

			X_UV_0 = SetTexcoord2();
			X_NRM = SetTexcoord3();
			C_ROZ_SCALE = SetConst(rozut_scale);
			C_SCALE_BIRD = SetConst(bird_scale);
			C_ROZUT = SetConst(rozut_x, rozut_y, rozut_z);
			C_WINGS_SPEED = SetConst(wings_speed);
			C_WINGS_D = SetConst(1.0 / wings_speed);
			C_FLY_FAC = SetConst(fly_fac);
			C_ZUR_ZUR = SetConst(zur_zur);


			if(clr_tex != s_tex_def)
			{
				S_CLR = SetTexture(clr_tex);
			}

			extern float_dat TIME;
			C_TIME_1 = SetConst(TIME * 1.1 * fly_speed);
			C_TIME_2 = SetConst(TIME * 1.7 * fly_speed);
			C_TIME_3 = SetConst(TIME * 1.2 * fly_speed);
			C_TIME_4 = SetConst(TIME * 0.35 * fly_speed);
			C_TIME_5 = SetConst(TIME * fly_speed);

			C_MID = SetConst(((float_dat)mat_dielectric) / 255.0);

			VertexShader()
			{
				use Instancing();
				hlsl()
				{

					#include <master_new.hlsl>

					void main()
					{
						X_UV_0 = Decode_UV(I_UV_0);
						float2 uv_1 = Decode_UV(I_UV_1);


						float msk_1 = saturate(-I_UV_0.y * 0.0006 * C_WINGS_D);
						float4 pos_ms = Decode_Pos(I_POS_0);

						float3 pos_v_max = (I_VCLR.xyz * 2.0 - 1.0) * 0.5 ;
						float3 pos_v_majtanie = (sin(( TIME - msk_1 + I_VCLR.a *12.56) * C_WINGS_SPEED ) * 0.5 + 0.5) * (I_VCLR.xyz * 2.0 - 1.0) * (C_ZUR_ZUR+1.0);

						float msk_majtanie = saturate((sin( C_TIME_1 + I_VCLR.a * 31.6 ) + sin( C_TIME_2 + I_VCLR.a * 12.6 )) * 2.0 + 0.5);
						pos_ms.xyz += lerp( pos_v_max,  pos_v_majtanie , msk_majtanie);
						pos_ms.xz = lerp (pos_ms.xz, uv_1, C_ZUR_ZUR);
						pos_ms.xyz *= C_SCALE_BIRD;
						pos_ms.x += (-sin( C_TIME_3 + I_VCLR.a * 20) + sin(C_TIME_4 + I_VCLR.a * 17.5 ))*C_FLY_FAC;
						pos_ms.y += (-cos(C_TIME_1 + I_VCLR.a * 31.6 - 0.5) - cos(C_TIME_2 + I_VCLR.a * 12.6 - 0.5)) *  C_FLY_FAC;
						pos_ms.z += (sin(C_TIME_5 + I_VCLR.a * 134.7) + sin(C_TIME_4 + I_VCLR.a * 55.5))*C_FLY_FAC;
						float3 dis_vec = float3( -sin ( I_VCLR.a * 127.5 ) , -sin(I_VCLR.a * 23.3 ) * 0.76 , -sin(I_VCLR.a *  133.8));
						pos_ms.xyz+= normalize( dis_vec ) * sin(I_VCLR.a * 51.23 ) * C_ROZUT * C_ROZ_SCALE;

						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);


						float3 nrm_ws = Mul33(I_NRM_0, MODEL_XFORM_4x3);
						float3 nrm_es = Mul33(nrm_ws, VIEW_XFORM);
						float3 nrm_n_es = normalize(nrm_es);

						X_NRM = nrm_n_es;
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
 					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

					#include <master_new.hlsl>

					void main()
					{

						#if defined(S_CLR)
							FLOAT4 clr = Sample(S_CLR, X_UV_0);
							O_DIF = clr;
							O_DIF.a = saturate(clr.a * 2.0 - 1.0);
						#else
							O_DIF = FLOAT4(0.1, 0.1, 0.1, 0.1);
						#endif
						O_SPC.xyz = SwizzleXXX(0.0);
						O_SPC.w = O_DIF.w;
						FLOAT3 nrm_es = X_NRM;

						O_NRM.xyz = nrm_es * 0.5 + 0.5;
						O_NRM.w = 1.0;
					}
				}
			}
		}
	}
}
