//new

using engineflags;
using settemplates;

template
{
	category Main
	{
		class Basic
		{
			string_dat clr_tex = s_tex_def : editor(ImageFileNameEditor), display(Color);
			float_dat f_l_factor = 1.0 : editor(FloatSpinEditor), display(factor);
			float_dat f_l_th = 0.2 : editor(FloatSpinEditor), display(gubo);
			float_dat f_l_sc = 1.0 : editor(FloatSpinEditor), display(scale);
			float_dat f_uv_sc = 1.0 : editor(FloatSpinEditor), display(uv scale);
			float_dat f_c_f = 1.0 : editor(FloatSpinEditor), display(color factor);
		}
	}

	templatebody()
	{
		tech("trn")
		{
			use SetupMaterial();
			Cull(NONE);
			DepthFunc(LEQUAL, TRUE);
			extern float_dat TIME;
			BlendFunc(ONE, ONE, ONE, ONE);
			DepthFunc(LEQUAL, FALSE);

			Input I_POS_0 = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_UV_1 = new InputFloat2("TEXCOORD1");
			Input I_CLR_USR = new InputFloat4("COLOR_USER");
			Input I_CLR_0 = new InputFloat4("COLOR0");

			Output O_CLR = new OutputFLOAT4("COLOR0");

			X_UV_0 = SetTexcoord2();
			X_EXT = SetTexcoord3("FLOAT");

			extern float_dat f_pp_hdr_intensity_emissive;
			C_EMISSIVE_INTENSITY = SetConst(f_pp_hdr_intensity_emissive);

			C_L_FACTOR = SetConst(f_l_factor* 0.1);
			C_L_TH = SetConst(f_l_th );
			C_UV_SC = SetConst(f_uv_sc * 0.1 );
			C_L_SC = SetConst(f_l_sc * 7.0 );
			C_C_F = SetConst(f_c_f  );

			if(clr_tex != s_tex_def)
			{
				S_CLR = SetTexture(clr_tex, LINEAR_MIP_LINEAR, WRAP, CLAMP, TRUE);
				Define ("D_CLR_ON", 1);

			}

			VertexShader()
			{
				use Instancing();
				hlsl()
				{

					#include <master_new.hlsl>
					#include <fog.hlsl>

					void main()
					{
						float4 usr_1;
						float4 usr_0 = Decode_Usr(I_CLR_USR, usr_1);

						float4 pos_ms = Decode_Pos(I_POS_0);
						float2 uv_0 = Decode_UV(I_UV_0) * float2(1,-1) + float2(0,1);
						float2 uv_1 = Decode_UV(I_UV_1)- float2(0,1) ;
						float4 v_vec = SwizzleXXXX(0.0);
						v_vec.xz = pos_ms.xz;
						pos_ms.xz = SwizzleXX(0.0);

						float msk_0 = usr_0.a;
						float4 msk_1 = pos_ms.y * float4( 0.274, -0.149, 0.36, 0.535)* C_L_SC;
						float4 msk_2 = pos_ms.y * float4( 0.164, 0.265, -0.05, 0.618)* C_L_SC;
						float msk_3 = saturate(-abs((pos_ms.y*4.0-2.0)*1.0) + 2.0);


						float4 time_f = floor( frac( ( TIME + usr_0.r ) * 0.01 * float4( 0.35, 0.532, 0.43, 0.21)) * 4000.0 )* float4( 2.5312, 1.896, 2.013, 2.111)* 10.56;
						pos_ms.xy = lerp(pos_ms.xy, uv_0, msk_0);
						float2 dis_vec = lerp( float2(1.0,0.0),uv_1, msk_0);

						float4 ligtning_1 = abs(frac( time_f + msk_1) - 0.5)*4-1;
						float ligtning_11 = (ligtning_1.x + ligtning_1.y + ligtning_1.z + ligtning_1.w) / 4.0;

						float4 ligtning_2 = abs(frac( time_f + msk_2) - 0.5)*4-1;
						float ligtning_22 = (ligtning_2.x + ligtning_2.y + ligtning_2.z + ligtning_2.w) / 4.0;

						float2 new_v_vec;
						new_v_vec.y = dot(v_vec.xy,dis_vec.yx );
						new_v_vec.x = dot(v_vec.xy,-dis_vec.xy);
						v_vec.xy =new_v_vec;

						pos_ms.xy += ligtning_11*dis_vec.xy *msk_3 * C_L_FACTOR;
						pos_ms.z += ligtning_22*msk_3 * C_L_FACTOR;

						float4 pos_ws = Mul_Pos(pos_ms , MODEL_XFORM_4x3);
						float4 v_vec_ws = Mul_Pos(v_vec , MODEL_XFORM_4x3);
						float3 pivot_ws = float3(MODEL_XFORM_4x3[0].w, MODEL_XFORM_4x3[1].w, MODEL_XFORM_4x3[2].w);
						pos_ws.xyz +=  normalize(v_vec_ws.xyz)*C_L_TH;
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						X_EXT = Scattering_Ext(length(pos_ws.xyz - CAMERA_POS_WS.xyz));
						X_EXT *= C_EMISSIVE_INTENSITY;
						X_UV_0 = float2(length(pos_ws.xyz - pivot_ws)*C_UV_SC - time_f.z  ,I_CLR_0.a);
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{

					#include <master_new.hlsl>

					void main()
					{

						#if defined(D_CLR_ON)
							FLOAT3 out_ems =Sample_h3(S_CLR, X_UV_0);

							out_ems *= X_EXT;
							O_CLR.w = 0.0;
							O_CLR.xyz = out_ems;
						#else
							O_CLR = FLOAT4(0.015, 0.4, 0.9, 1);
						#endif
						O_CLR.xyz *= C_C_F;
					}
				}
			}
		}
	}
}