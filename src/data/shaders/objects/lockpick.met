//new

using engineflags;
using settemplates;

template
{

	public string TemplateCategory() { return "Objects special"; }

	category Main
	{
		class Basic
		{
			string_dat clr_tex = "" : editor(ImageFileNameEditor), display(Color);
			string_dat nrm_tex = "" : editor(ImageFileNameEditor), display(Normal);
			float_dat f_nrm_scale = 1.0 : editor(FloatSpinEditor), display(Normal Scale);
		}
		class Lighting
		{
			string_dat env_tex = "" : editor(ImageFileNameEditor), display(Env);
			float_dat f_env_scale = 1.0 : editor(FloatSpinEditor), display(Env Scale);
		}
	}
	public void depth_pass(bool_dat clear_on )
	{
		string_dat technique = If(clear_on, "std_dpt_clear", "std_dpt");
		int_dat culling = If(clear_on, CCW, CW);
		int_dat depth_cnd = If(clear_on, GEQUAL, LEQUAL);
		tech(technique)
		{
			Cull(culling);

			ColorFunc(FALSE, FALSE, FALSE, FALSE);
			DepthFunc(depth_cnd, TRUE);

			Input I_POS_MS = new InputFloat4("POSITION");

			Output O_CLR = new OutputFLOAT4("COLOR0");

			extern int_dat SHADER_PATH;

			VertexShader()
			{
				use Instancing();

				hlsl()
				{
					#include <common.hlsl>
					#include <master_new.hlsl>

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_MS);
						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);
					}
				}
			}
			if(SHADER_PATH != SM31)
			{
				PixelShader()
				{
					hlsl()
					{
						#include <common.hlsl>
						#include <master_new.hlsl>

						void main()
						{
							O_CLR = float4(1.0, 1.0, 1.0, 1.0);
						}
					}
				}
			}
		}
	}
	templatebody()
	{
		platform("*", "none; instancing");
	
		depth_pass(TRUE);
		depth_pass(FALSE);

		tech("std")
		{
			bool_dat nrm_on = (nrm_tex != "");
			bool_dat clr_on = (clr_tex != "");
			
			use SetupMaterial();
			Cull(CW);
			DepthFunc(LEQUAL, TRUE);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, ZERO, ONE);

			Input I_POS_0 = new InputFloat4("POSITION");
			Input I_NRM_0 = new InputFloat3("NORMAL0");

			Output O_CLR = new OutputFLOAT4("COLOR0");
			X_NRM = SetTexcoord3();
			X_CAM_DIR_WS = SetTexcoord3();

			if(clr_on | nrm_on)
			{
				Input I_UV_0 = new InputFloat2("TEXCOORD0");
				X_UV_0 = SetTexcoord2();
				if(clr_on)
				{
					S_CLR = SetTexture(clr_tex);
				}
			}
			
			if(nrm_on)
			{
				S_NRM = SetTexture(nrm_tex);
				C_NRM_SCALE = SetConst(f_nrm_scale);

				Input I_TNG_0 = new InputFloat4("TANGENT");

				X_BNR = SetTexcoord3();
				X_TNG = SetTexcoord3();
			}

			C_ENV_SCALE = SetConst(f_env_scale);
			if(env_tex != "")
			{
				S_ENV = SetTextureCUBE(env_tex);
			}
			else
			{
				Define("D_ENV_DEF_ON", 1);
				S_ENV = SetTextureCUBE(i_um_env, LINEAR_MIP_LINEAR, CLAMP, CLAMP, TRUE);
			}

			VertexShader()
			{
				use Instancing();
				hlsl()
				{
					#include <master_new.hlsl>

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_0);
						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						X_CAM_DIR_WS = pos_ws.xyz - CAMERA_POS_WS.xyz;
						X_UV_0 = Decode_UV(I_UV_0);

						float3 nrm_ws = Mul33(I_NRM_0, MODEL_XFORM_4x3);
						float3 nrm_n_ws = normalize(nrm_ws);
						X_NRM = nrm_n_ws;
						
						#if defined(X_TNG)
							float3 tng_ws = Mul33(I_TNG_0.xyz, MODEL_XFORM_4x3);
							float3 tng_n_ws = normalize(tng_ws);
							X_TNG = tng_n_ws;

							float3 bnr_n_ws = cross(nrm_n_ws, tng_n_ws);
							X_BNR = bnr_n_ws * I_TNG_0.w;
						#endif
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
					#include <master_new.hlsl>

					void main()
					{
						#if defined(X_TNG)
							FLOAT3 nrm = SwizzleXXX(1.0);
							FLOAT3 M_ES2TS[3];
							M_ES2TS[0] = X_TNG;
							M_ES2TS[1] = X_BNR;
							M_ES2TS[2] = X_NRM;
							nrm.xy = Sample(S_NRM, X_UV_0).ag * 2.0 - 1.0;
							nrm.xy *= C_NRM_SCALE;
							FLOAT3 nrm_ws = Mul33T(nrm, M_ES2TS);
							FLOAT3 nrm_n_ws = normalize(nrm_ws);
						#else
							FLOAT3 nrm_n_ws = normalize(X_NRM);
						#endif
						
						O_CLR = SwizzleXXXX(1.0);
						#if defined(S_CLR)
							O_CLR = Sample(S_CLR, X_UV_0);
						#endif							
						
						FLOAT3 rfl_ws = reflect(X_CAM_DIR_WS, nrm_n_ws);
						FLOAT rgh = 5.0 - 5.0 * O_CLR.w; //(1.0 - O_CLR.w) * 5.0 - hack
						FLOAT3 spc = SampleCUBE_h3(S_ENV, rfl_ws, rgh);
						#if defined(D_ENV_DEF_ON)
							spc = spc.ggg;
						#endif
						FLOAT3 cam_dir_n = normalize(-X_CAM_DIR_WS);
						FLOAT fresnel = saturate(dot(nrm_n_ws, cam_dir_n));
						fresnel = C_ENV_SCALE - C_ENV_SCALE * fresnel; // *(1-fresnel)
						O_CLR.xyz *= spc + fresnel * fresnel;
						
						FLOAT2 uv_screen = UV_Screen(V_POS_SS_TC);
						FLOAT2 screen_masks = abs(uv_screen * 2.0 - 1.0);
						O_CLR.w = max(screen_masks.x, screen_masks.y);
						O_CLR.w = 1.0 - O_CLR.w;
						O_CLR.w = saturate(3.0 * O_CLR.w - 1.0);
					}
				}
			}
		}
	}
}
