//new

using engineflags;
using settemplates;

template
{
	category Main
	{
		class Basic
		{
			string_dat clr_tex = s_tex_def : editor(ImageFileNameEditor), display(Color);
			float_dat f_l_factor = 1.0 : editor(FloatSpinEditor), display(msk blend factor);
			float_dat f_l_time = 1.0 : editor(FloatSpinEditor), display(time factorr);
			float_dat f_l_th = 0.2 : editor(FloatSpinEditor), display(gubo);
			float_dat f_uv_sc = 1.0 : editor(FloatSpinEditor), display(uv scale);
			float_dat f_c_f = 1.0 : editor(FloatSpinEditor), display(color factor);
		}
	}
	
	templatebody()
	{
		platform("*", "none; instancing");

		tech("trn")
		{
			use SetupMaterial();
			Cull(NONE);

			extern float_dat TIME;
			BlendFunc(ONE, ONE, ONE, ONE);
			DepthFunc(LEQUAL, FALSE);
			
			Input I_POS_0 = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_UV_1 = new InputFloat2("TEXCOORD1");
			Input I_CLR_USR = new InputFloat4("COLOR_USER");
			Input I_CLR_0 = new InputFloat4("COLOR0");
			
			Output O_CLR = new OutputFLOAT4("COLOR0");
			X_UV_0 = SetTexcoord2();				
			X_EXT = SetTexcoord3("FLOAT");
			X_MSK = SetTexcoord("FLOAT");
		
			extern float_dat f_pp_hdr_intensity_emissive;
			C_EMISSIVE_INTENSITY = SetConst(f_pp_hdr_intensity_emissive);

			C_L_FACTOR = SetConst(f_l_factor);
			C_L_TH = SetConst(f_l_th );
			C_UV_SC = SetConst(f_uv_sc );
			C_C_F = SetConst(f_c_f  );
			C_T_F = SetConst(f_l_time * TIME );
			
			if(clr_tex != s_tex_def)
			{
				S_CLR = SetTexture(clr_tex, LINEAR_MIP_LINEAR, WRAP, CLAMP, TRUE);
				Define ("D_CLR_ON", 1);

			}
					
			VertexShader()
			{
				use Instancing();
				hlsl()
				{
					
					#include <master_new.hlsl>
					#include <fog.hlsl>
					
					void main()
					{
						float4 usr_1;
						float4 usr_0 = Decode_Usr(I_CLR_USR, usr_1);
						float msk_0 = usr_0.a; 
						float time_f =floor ( ( C_T_F  + usr_0.r ) * 4.1)*0.22 + floor ( ( C_T_F *0.78 + usr_0.r ) * 3.1)*0.51 - floor ( ( C_T_F *0.63 + usr_0.r ) * 2.71)*0.321 +  floor ( ( C_T_F *0.43 + usr_0.r ) * 5.71)*0.521;
						
						
						float2 uv_0 = Decode_UV(I_UV_0) * float2(-1,-1)  + float2(0,1);
						float2 uv_1 = normalize(Decode_UV(I_UV_1)- float2(0,1) );
						float2 norm_vec = lerp( float2(1,0), uv_1, msk_0);
						float4 pos_ms = Decode_Pos(I_POS_0);
						float3 new_pos_ms = pos_ms.xyz;
						new_pos_ms.xz = SwizzleXX(0.0);
						new_pos_ms.xy = lerp(new_pos_ms.xy, uv_0, msk_0);
					
						float3 vec_displace = SwizzleXXX(0.0);
						vec_displace.xy += norm_vec * pos_ms.x;
						vec_displace.z += pos_ms.z;
						float3 vec_displace_ws = Mul33(vec_displace, MODEL_XFORM_4x3);
						float uv_scale = length(Mul33(float3(1,0,0), MODEL_XFORM_4x3));
	
						float blend_msk = pos_ms.y -0.5 ;
						// X_MSK = saturate(abs(frac(blend_msk) - 0.5)*uv_scale * C_L_FACTOR/C_L_TH);
						
						float3 vec_p_nrm_ms = pos_ms.zyx * float3(1,0,1);
						vec_p_nrm_ms.xz = ((vec_p_nrm_ms.x * vec_p_nrm_ms.z ) < 0.0 )?  abs(vec_p_nrm_ms.xz) * float2(-1,-1): abs(vec_p_nrm_ms.xz) * float2(-1,1);
						float3 vec_p_nrm_ws = Mul33(vec_p_nrm_ms, MODEL_XFORM_4x3);
						float3 vec_p_nrm_ws_n = normalize(vec_p_nrm_ws);

						pos_ms.xyz = new_pos_ms;
						float4 pos_ws = Mul_Pos(pos_ms , MODEL_XFORM_4x3);
						pos_ws.xyz += normalize(vec_displace_ws) * C_L_TH;
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);
		
						float4 pivot_ws = float4(MODEL_XFORM_4x3[0].w, MODEL_XFORM_4x3[1].w, MODEL_XFORM_4x3[2].w, 1.0);
						float3 camera_vec_ws = normalize( pos_ws.xyz - CAMERA_POS_WS.xyz);
						X_MSK =  saturate(abs(dot(camera_vec_ws, vec_p_nrm_ws_n ) )  * 5. - 4);
						
						X_EXT = Scattering_Ext(length(pos_ws.xyz - CAMERA_POS_WS.xyz));
						X_EXT *= C_EMISSIVE_INTENSITY;
						X_UV_0 = float2(length(pos_ms.xyz ) *uv_scale *0.5* C_UV_SC /C_L_TH + time_f ,I_CLR_0.a);
						
					}
				}
			}
			
			PixelShader()
			{
				hlsl()
				{
					
					#include <master_new.hlsl>	
					
					void main()
					{

						#if defined(D_CLR_ON)		
							FLOAT3 out_ems =Sample_h3(S_CLR, X_UV_0);

							out_ems *= X_EXT;  
							O_CLR.w = 0.0;
							O_CLR.xyz = out_ems;
						#else	
							O_CLR = FLOAT4(0.015, 0.4, 0.9, 1);
						#endif
						O_CLR.xyz *= C_C_F*X_MSK;

					}
				}
			}
		}
	}
}