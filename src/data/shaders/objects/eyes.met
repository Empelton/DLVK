//new

using engineflags;
using settemplates;
using depth_pass;
using attribs;
using ice;
// using highlight_a;
template
{
	public string TemplateCategory() { return "Objects charactes"; }

	
	variants
    {
        bool_dat b_fr : display(fr);
    }
	
	category Basic
	{
		class Main
		{
			string_dat dif_0_tex = "" : editor(ImageFileNameEditor), display(Base color texture);
			string_dat nrm_0_tex = "" : editor(ImageFileNameEditor), display(Base normal texture);
			string_dat dye_tex = "" : editor(ImageFileNameEditor), display(Dye texture);
			string_dat ems_tex = "" : editor(ImageFileNameEditor), display(Ems texture);
		}
		class Self illumination
		{
			bool_dat ems_user_on = FALSE : display(Emissive controlled by user attribute enabled);
		}
		class Shaking
		{
			float_dat shake_scale = 0.0 : display(Strength);
			float_dat shake_speed = 80.0 : display(Speed);
			float_dat clr2nrm_delay = 0.0 : display(Delay betwen color and normal mapping);
		}
		class Deformation
		{
			float_dat deform_scale = 0.0 : display(Color by normal deformation stregth);
		}
	}

	category Advanced
	{
		class Factors
		{
			vec3_dat clr_0_factor = vec(1.0, 1.0, 1.0) : editor(ColorRGBEditor), display(Color);
			float_dat srf_0_factor = 1.0 : display(Surface);
			float_dat nrm_0_factor = 1.0 : display(Normal scale);
			vec4_dat ems_clr = vec(1.0, 1.0, 1.0, 1.0) : editor(ColorRGBAEditor), display(Emissive);
		}

		class Dynamic Factors
		{
			bool_dat ems_clr_dynamic_on = FALSE : display(Animated emissive color enabled);
		}

		class UV Factors
		{
			float_dat uv_scale = 1.0 : display(UV 0 scale - global);
			float_dat uv_scale_u = 1.0 : display(UV 0 scale - U);
			float_dat uv_scale_v = 1.0 : display(UV 0 scale - V);
			float_dat uv_offset_u = 0.0 : display(UV 0 offset - U);
			float_dat uv_offset_v = 0.0 : display(UV 0 offset - V);
		}

		class Sampling
		{
			int_dat tex_tile = CLAMP : converter(TexTile_Variants);
			int_dat filter_clr = ANISOTROPIC_MIP_POINT : converter(Filter_Variants);
		}
		class Env
		{
			string_dat env_tex = "eyes_env_def.dds" : editor(ImageFileNameEditor), display(Alternative enviroment texture);
			vec3_dat env_factor = vec(1.0, 1.0, 1.0) : editor(ColorRGBEditor), display(Env Factor);
			float_dat env_mask_min = 0.0 : display(Env Mask Minimum);
			float_dat env_mask_max = 1.0 : display(Env Mask Maximum);
			float_dat env_fresnel_min = 0.0 : display(Env Fresnel Mask Minimum);
			float_dat env_fresnel_max = 1.0 : display(Env Fresnel Mask Maximum);
			bool_dat env_fresnel_pow_on = FALSE : display(Env Fresnel Mask Powered);
			float_dat env_nrm_scale = 1.0 : display(Env Normal Scale);
		}
		class Parallax
		{
			string_dat parallax_tex = "" : editor(ImageFileNameEditor), display(Parallax texture);
			float_dat parallax_factor = 0.0 : display(Parallax factor);
		}

		// class Highlight
		// {
			// bool_dat highlight_on = FALSE : display(Highlight enabled);
		// }
		class Shadows
		{
			bool_dat cast_shadows_on = FALSE : display(Cast shadows enabled);
		}
		class Performance
		{
			bool_dat zpass_on = FALSE : display(Depth prepass enabled);
		}
        class Geometry
        {
            bool_dat static_on = FALSE;
        }
        class Gamma
        {
        	bool_dat gamma_correct_on = false;
		}
		class Ice
		{
			bool_dat b_ice_on = FALSE : display(Ice enabled);
			float_dat ice_uv_tile = 1.0 : display(Ice UV tiling);
		}
	}

	templatebody()
	{

		bool_dat clr_0_on = ((dif_0_tex != "") & ((clr_0_factor.x + clr_0_factor.y + clr_0_factor.z) > 0.0));
		bool_dat nrm_0_on = ((nrm_0_tex != "") & (nrm_0_factor > 0.0));


		tech("opq2")
		{
			Cull(CW);

			DepthFunc(LEQUAL, TRUE);

			AddLine("StencilMarker();");

			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_NRM_MS = new InputFloat3("NORMAL0");

			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");
			Output O_NRM = new OutputFLOAT4("COLOR2");

			float_dat mid_nrm = ((float_dat)mat_dielectric) / 255.0;
            C_NRM_FACTORS = SetConst(0.5, 0.0, mid_nrm); //X: nrm scale/bias, Y: mid scale(zero), Z: MID

			if(parallax_tex != "")
			{
			    Define("D_PARALLAX_ON", 1);
                C_PARALLAX_SCALE = SetConst(parallax_factor);
				X_CAM_TS = SetTexcoord3("FLOAT");
				S_HGT = SetTexture2D(parallax_tex, LINEAR_MIP_POINT, CLAMP, CLAMP, FALSE);

			}

            if(gamma_correct_on)
            {
                Define("D_GAMMA_CORRECT", 1);
                C_CLR_0_FACTOR = SetConst(Gamma_Decode(clr_0_factor.x), Gamma_Decode(clr_0_factor.y), Gamma_Decode(clr_0_factor.z), Gamma_Decode(srf_0_factor));
            }
            else
            {

                C_CLR_0_FACTOR = SetConst(clr_0_factor.x, clr_0_factor.y, clr_0_factor.z, srf_0_factor);
            }

			bool_dat shake_on = ((shake_scale > 0.0) & (shake_speed > 0.0));
			if(((uv_scale_u * uv_scale_v * uv_scale > 0.0) & (uv_scale_u * uv_scale_v * uv_scale != 1.0)) | shake_on)
			{
				Define("D_UV_SCALE_OFFSET_ON", 1);
				float_dat uv_scale_u_inv = 1.0 / (uv_scale_u * uv_scale);
				float_dat uv_scale_v_inv = 1.0 / (uv_scale_v * uv_scale);
				float_dat uv_offset_u_scaled = uv_offset_u * uv_scale_u_inv + 0.5 - uv_scale_u_inv * 0.5;
				float_dat uv_offset_v_scaled = uv_offset_v * uv_scale_v_inv + 0.5 - uv_scale_v_inv * 0.5;

				float_dat time_func = 0.0;

				if( !b_fr & !b_ice_on )
				{
					extern float_dat TIME;
					time_func += TIME;
				}
				float_dat shake_u_time = shake_speed * time_func;
				float_dat shake_v_time = shake_speed * (time_func - 7.31);
				uv_offset_u_scaled += sin(shake_u_time) * shake_scale;
				uv_offset_v_scaled += sin(shake_v_time) * shake_scale;
				C_UV_SCALE_OFFSET = SetConst(uv_scale_u_inv, uv_scale_v_inv, uv_offset_u_scaled, uv_offset_v_scaled);
				if(shake_on & (clr2nrm_delay > 0.0))
				{
					shake_u_time = shake_speed * (time_func + clr2nrm_delay);
					shake_v_time = shake_speed * (time_func - 7.31 + clr2nrm_delay);
					uv_offset_u_scaled += sin(shake_u_time) * shake_scale;
					uv_offset_v_scaled += sin(shake_v_time) * shake_scale;
					C_UV_CLR_SCALE_OFFSET = SetConst(uv_scale_u_inv, uv_scale_v_inv, uv_offset_u_scaled, uv_offset_v_scaled);
				}
			}



			if(dye_tex != "")
			{
				Input I_UV_1 = new InputFloat2("TEXCOORD1");
				X_UV_1 = SetTexcoord2("FLOAT");
				S_DYE = SetTexture2D(dye_tex, LINEAR_MIP_POINT, CLAMP, CLAMP, gamma_correct_on);
			}


			if(nrm_0_on) { X_NRM_CS = SetTexcoord3("FLOAT"); }
			else { X_NRM_OUT = SetTexcoord4("FLOAT"); }

			if(clr_0_on | nrm_0_on)
			{
				Input I_UV_0 = new InputFloat2("TEXCOORD0");
				X_UV_0 = SetTexcoord2("FLOAT");

				if(clr_0_on)
				{
					S_DIF = SetTexture2D(dif_0_tex, filter_clr, tex_tile, tex_tile, gamma_correct_on);
					if(shake_on & (clr2nrm_delay > 0.0))
					{
						X_UV_CLR = SetTexcoord2("FLOAT");
					}
				}

				if(nrm_0_on)
				{
					X_TNG_CS = SetTexcoord3("FLOAT");
					X_BNR_CS = SetTexcoord3("FLOAT");
					S_NRM_0 = SetTexture2D(nrm_0_tex, LINEAR_MIP_LINEAR, tex_tile, tex_tile, FALSE);
                    C_NRM_0_SCALE = SetConst(nrm_0_factor);
                    C_DEFORM_SCALE = SetConst(deform_scale);
				}
			}
			if((nrm_0_on)|(parallax_tex != ""))
			{
				Input I_TNG_MS = new InputFloat4("TANGENT0");
			}




			float_dat env_mask_scale = 1.0 / (env_mask_max - env_mask_min);
			float_dat env_mask_bias = -env_mask_min * env_mask_scale;

			if((env_tex != "") & ((env_mask_scale + env_mask_bias) > 0.0) & (max(env_fresnel_max, env_fresnel_min) > 0.0) & ((env_factor.x + env_factor.y + env_factor.z) > 0.0))
			{
				if(env_tex != "") { S_ENV = SetTextureCUBE(env_tex, LINEAR_NO_MIP, CLAMP, CLAMP, gamma_correct_on); }
				else
				{
					Define("D_ENV_LUM_ON", 1);
					S_ENV = SetTextureCUBE(i_um_env, LINEAR_NO_MIP, CLAMP, CLAMP, gamma_correct_on);
				}

				bool_dat fresnel_on = (min(env_fresnel_max, env_fresnel_min) < 1.0) & (abs(env_fresnel_max - env_fresnel_min) > 0.0);

				bool_dat env_nrm_on = (nrm_0_on & (env_nrm_scale > 0.0));

				if(fresnel_on | env_nrm_on)
				{
					X_POS_CS = SetTexcoord3("FLOAT");
                    if(env_nrm_on & (env_nrm_scale < 1.0))
                    {
                        Define("D_ENV_NRM_SCALE_ON", 1);
                        C_ENV_NRM_SCALE = SetConst(env_nrm_scale);
                    }
					if(fresnel_on)
					{
						float_dat env_fresnel_scale = 1.0 / (env_fresnel_max - env_fresnel_min);
						float_dat env_fresnel_bias = -env_fresnel_min * env_fresnel_scale;

						float_dat env_fresnel_pow = If(env_fresnel_pow_on, 2.0, 1.0);

                        Define("D_ENV_FRESNEL_SCALE_ON", 1);
                        C_ENV_FRESNEL_SCALE = SetConst(env_fresnel_scale);
                        Define("D_ENV_FRESNEL_BIAS_ON", 1);
                        C_ENV_FRESNEL_BIAS = SetConst(env_fresnel_bias);
                        C_ENV_FRESNEL_POW = SetConst(env_fresnel_pow);
						if(!nrm_0_on) { X_NRM_CS = SetTexcoord3("FLOAT"); }
					}
				}
				if(!env_nrm_on) { X_RFL_WS = SetTexcoord3("FLOAT"); }

                C_ENV_MASK_SCALE = SetConst(env_mask_scale);
                C_ENV_MASK_BIAS = SetConst(env_mask_bias);

                if(gamma_correct_on)
                {
                    C_ENV_FACTOR = SetConst(Gamma_Decode(env_factor.x), Gamma_Decode(env_factor.y), Gamma_Decode(env_factor.z));
                }
                else
                {
                    C_ENV_FACTOR = SetConst(env_factor.x, env_factor.y, env_factor.z);
                }
			}

            if(!static_on)
            {
                MarkStencilDynamic();
            }

			VertexShader()
			{
				hlsl()
				{

					#include <master_new.hlsl>

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_MS);

						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);

						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						#if defined(S_DIF) || defined(S_NRM_0)
							float2 uv_0 = Decode_UV(I_UV_0);
							#if defined(D_UV_SCALE_OFFSET_ON)
								#if defined(X_UV_CLR)
									X_UV_CLR = uv_0 * C_UV_CLR_SCALE_OFFSET.xy + C_UV_CLR_SCALE_OFFSET.zw;
								#endif
								uv_0 = uv_0 * C_UV_SCALE_OFFSET.xy + C_UV_SCALE_OFFSET.zw;
							#endif
							X_UV_0 = uv_0;
						#endif

						#if defined(S_DYE)
							X_UV_1 = Decode_UV(I_UV_1);
						#endif

						float3 nrm_ws = Mul33(I_NRM_MS, MODEL_XFORM_4x3);
						float3 nrm_cs = Mul33(nrm_ws, VIEW_XFORM);
						float3 nrm_n_cs = normalize(nrm_cs);
						#if defined(X_NRM_OUT)
                            X_NRM_OUT = nrm_n_cs.xyzx * C_NRM_FACTORS.xxxy + C_NRM_FACTORS.xxxz;
						#endif
						#if defined(X_NRM_CS)
							X_NRM_CS = nrm_n_cs;
						#endif
						#if defined(S_NRM_0)
							float3 tng_ws = Mul33(I_TNG_MS.xyz, MODEL_XFORM_4x3);
							float3 tng_cs = Mul33(tng_ws, VIEW_XFORM);
							float3 tng_n_cs = normalize(tng_cs);
							X_TNG_CS = tng_n_cs;

							float3 bnr_n_cs = cross(nrm_n_cs, tng_n_cs);
							bnr_n_cs *= I_TNG_MS.w;
							X_BNR_CS = bnr_n_cs;
						#endif

						#if defined(S_ENV)||defined(D_PARALLAX_ON)
							#if defined(X_RFL_WS)||defined(D_PARALLAX_ON)
								float3 cam_dir_ws = pos_ws.xyz - CAMERA_POS_WS.xyz;
							#endif
							#if defined(D_PARALLAX_ON)
								 X_CAM_TS = Mul33T(cam_dir_ws,  MODEL_XFORM_4x3) * I_TNG_MS.w ;
							#endif
						#endif


						#if defined(S_ENV)
							#if defined(X_RFL_WS)
								float3 nrm_n_ws = normalize(nrm_ws);
								X_RFL_WS = reflect(cam_dir_ws, nrm_n_ws);
							#endif

							#if defined(X_POS_CS)||defined(D_PARALLAX_ON)
								X_POS_CS = Mul_Pos(pos_ws, VIEW_XFORM).xyz;
							#endif
						#endif
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
 					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

					#include <master_new.hlsl>

					void main()
					{
						#if defined(S_NRM_0) || defined(D_PARALLAX_ON)
							float3 E2T_XFORM[3];
							E2T_XFORM[0] = X_TNG_CS;
							E2T_XFORM[1] = X_BNR_CS;
							E2T_XFORM[2] = X_NRM_CS;
						#endif

						#if defined(X_NRM_OUT)
							O_NRM = X_NRM_OUT;
						#else
							#if defined(S_NRM_0)
								FLOAT3 nrm_ts = FLOAT3(0.0, 0.0, 1.0);
								nrm_ts.xy = Sample(S_NRM_0, X_UV_0).ag * 2.0 - 1.0;
                                nrm_ts.xy *= C_NRM_0_SCALE;
								FLOAT3 nrm_cs = Mul33T(nrm_ts, E2T_XFORM);
								FLOAT3 nrm_n_cs = normalize(nrm_cs);
							#else
								FLOAT3 nrm_n_cs = X_NRM_CS; //isn't normalized
							#endif

                            O_NRM = nrm_n_cs.xyzx * C_NRM_FACTORS.xxxy + C_NRM_FACTORS.xxxz;
						#endif

                        O_DIF = C_CLR_0_FACTOR;

						#if defined(S_ENV)
							#if defined(X_POS_CS)
								#if defined(S_NRM_0)
									FLOAT3 nrm_n_cs_4_rfl = nrm_n_cs;
                                    #if defined(D_ENV_NRM_SCALE_ON)
                                        nrm_n_cs_4_rfl = lerp(X_NRM_CS.xyz, nrm_n_cs_4_rfl, C_ENV_NRM_SCALE);
										nrm_n_cs_4_rfl = normalize(nrm_n_cs_4_rfl);
									#endif
								#else
									FLOAT3 nrm_n_cs_4_rfl = normalize(X_NRM_CS);
								#endif

                                #if defined(D_ENV_FRESNEL_SCALE_ON) && defined(D_ENV_FRESNEL_BIAS_ON)
									FLOAT3 cam_dir_n = normalize(X_POS_CS);
									FLOAT fresnel = saturate(1.0 - dot(-nrm_n_cs_4_rfl, cam_dir_n));
                                    fresnel = saturate(fresnel * C_ENV_FRESNEL_SCALE + C_ENV_FRESNEL_BIAS);
                                    fresnel = pow(fresnel, C_ENV_FRESNEL_POW);
								#endif
							#endif

							#if defined(X_RFL_WS)
								FLOAT3 rfl_ws = X_RFL_WS;
							#else
								FLOAT3 rfl_cs = reflect(X_POS_CS, nrm_n_cs_4_rfl);
								FLOAT3 rfl_ws = Mul33(rfl_cs, INVVIEW_XFORM);
							#endif

							FLOAT3 v_env = SampleCUBE_h3(S_ENV, rfl_ws, 0.0);
							#if defined(D_ENV_LUM_ON)
								v_env = v_env.yyy;
							#endif
                            v_env *= C_ENV_FACTOR;

							FLOAT3 env_mask = SwizzleXXX( saturate(O_DIF.w * C_ENV_MASK_SCALE + C_ENV_MASK_BIAS) );

                            #if defined(D_ENV_FRESNEL_SCALE_ON) && defined(D_ENV_FRESNEL_BIAS_ON)
								env_mask *= fresnel;
							#endif

							#if defined(S_DYE)
								env_mask *= dye;
							#endif
						#endif

						#if defined(S_DIF)

							#if defined(X_UV_CLR)
								FLOAT2 uv_clr = X_UV_CLR;
							#else
								FLOAT2 uv_clr = X_UV_0;
							#endif


							#if defined(D_PARALLAX_ON)
								FLOAT3 cam_dir_ts = Mul33(X_POS_CS, E2T_XFORM);
								FLOAT3 cam_dir_n_ts = normalize(cam_dir_ts);
                                cam_dir_n_ts *= C_PARALLAX_SCALE;
								FLOAT hgt = Sample_h2(S_HGT, X_UV_0).g;
								uv_clr += cam_dir_n_ts.xy * hgt  ;
							#endif

							#if defined(S_NRM_0)
                                uv_clr += nrm_n_cs.xy * C_DEFORM_SCALE;
							#endif
							FLOAT4 clr_0 = Sample(S_DIF, uv_clr);
							clr_0.w = saturate(clr_0.w * 2.0 - 1.0);
							O_DIF *= clr_0;
						#endif

						#if defined(S_ENV)
							O_DIF.xyz = lerp(O_DIF.xyz, v_env, env_mask);
						#endif

						#if defined(S_DYE)
							FLOAT3 dye = Sample_h3(S_DYE, X_UV_1);
						#endif


						#if defined(S_DYE)
							O_DIF *= dye.xyzy;
						#endif

                        #if defined(D_GAMMA_CORRECT)
                            O_DIF.xyz = Gamma_Encode(O_DIF.xyz);
                        #endif
						
						O_SPC.xyz = SwizzleXXX(0.0);
						O_SPC.w = O_DIF.w;
					}
				}
			}
		}
		if(ems_tex != "")
		{
			tech("ems")
			{
				Cull(CW);

				BlendFunc(ONE, ONE, ZERO, ONE);
				DepthFunc(LEQUAL, FALSE);

				Input I_POS_MS = new InputFloat4("POSITION");
				Input I_UV_0 = new InputFloat2("TEXCOORD0");
				if(ems_user_on)
				{
					Define("D_EMS_USER_ON", 1);
					Input I_CLR_USR = new InputFloat4("COLOR_USER");
				}

				X_UV_0 = SetTexcoord2("FLOAT");
				X_EXT = SetTexcoord3("FLOAT");

				Output O_CLR = new OutputFLOAT4("COLOR0");

				S_EMS_0 = SetTexture(ems_tex, LINEAR_MIP_LINEAR, tex_tile, tex_tile, TRUE);

				extern float_dat f_pp_hdr_intensity_emissive;
				vec3_dat ems_clr_out = pow(ems_clr.xyz * ems_clr.w, 2.2);
				C_EMISSIVE_INTENSITY = SetConst(ems_clr_out * f_pp_hdr_intensity_emissive);

				VertexShader()
				{
					use Instancing();
					hlsl()
					{
						#include <master_new.hlsl>
						#include <fog.hlsl>

						void main()
						{
							float4 pos_ms = Decode_Pos(I_POS_MS);
							float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
							V_POS_OUT_TC = Pos_Out_WS(pos_ws);

							X_EXT = Scattering_Ext(length(pos_ws.xyz - CAMERA_POS_WS.xyz));
							X_EXT *= C_EMISSIVE_INTENSITY;

							#if defined(D_EMS_USER_ON)
								float4 damage_factors;
								float4 usr_0 = Decode_Usr(I_CLR_USR, damage_factors);

								X_EXT *= damage_factors.y;
							#endif

							X_UV_0 = Decode_UV(I_UV_0);
						}
					}
				}
				PixelShader()
				{
					hlsl()
					{
						#include <master_new.hlsl>

						void main()
						{
							O_CLR = Sample(S_EMS_0, X_UV_0);
							O_CLR.xyz *= X_EXT;
						}
					}
				}
			}
		}

		if(cast_shadows_on | zpass_on)
		{
			att_standard shadow_params = new att_standard();

			depth_pass dpt = new depth_pass(this);

			if(cast_shadows_on)
			{
				shadow_params.technique = "zfill";
				dpt.setup(shadow_params);
			}
			if(zpass_on)
			{
				shadow_params.technique = "dpt";
				dpt.setup(shadow_params);
			}
		}
		
		if(b_ice_on | b_fr)

		{
			att_standard in_params = new att_standard();
			in_params.ice_uv_tile = ice_uv_tile;
			ice ice_a = new ice(this);
			ice_a.setup(in_params);

		}
		
		// if(highlight_on)
		// {
			// highlight_a highlight = new highlight_a(this);
			// highlight.setup(in_params);
		// }
	}
}
