//new

using engineflags;
using settemplates;
using depth_pass;
using attribs;

template
{
    category Basic
    {
        class Main
        {
            string_dat clr_tex = "" : editor(ImageFileNameEditor), display(Color texture);
            int_dat tex_tile = CLAMP : converter(TexTile_Variants);
            bool_dat occlusion_on = TRUE;
        }
        // class Wind
        // {
            // bool_dat wind_bend_on = TRUE : display(Global bending enabled);
        // }
    }
    category Advanced
    {
        class Shadows
        {
            bool_dat cast_shadows = FALSE : display(Cast shadows enabled);
        }
        class Sampling
        {
            int_dat filter_clr = LINEAR_MIP_POINT : converter(Filter_Variants);
        }
        class Geometry
        {
            bool_dat static_on = true;
        }
    }

    templatebody()
    {
		platform("*", "none; instancing");

        tech("opq2")
        {

            Cull(NONE);
            DepthFunc(LEQUAL, TRUE);

            AddLine("StencilMarker();");

            Input I_POS_MS = new InputFloat4("POSITION");
            Input I_UV_0 = new InputFloat2("TEXCOORD0");

            X_UV_0 = SetTexcoord2();

            Output O_SPC = new OutputFLOAT4("COLOR0");
            Output O_DIF = new OutputFLOAT4("COLOR1");
            Output O_NRM = new OutputFLOAT4("COLOR2");

            C_FACTORS = SetConst(0.5, 0.0, ((float_dat)mat_leaves) / 255.0, 1.0); //X: nrm scale/bias, Y: mid scale(zero), Z: mid

            if(occlusion_on )
            {
                Input I_CLR_0 = new InputFloat4("COLOR0");

                // if(wind_bend_on)
                // {
                    // Define("D_WIND_BEND_ON", 1);
                    // X_NRM_ES = SetTexcoord4();
                // }

                if(occlusion_on)
                {
                    Define("D_OCCLUSION_ON", 1);
                    X_OCCLUSION = SetTexcoord2();
                }
            }
            extern mtx_dat VIEW_XFORM;
            C_UP_DIR__MID = SetConst(mulv(VIEW_XFORM, vec(0.0, 1.0, 0.0)) * 0.5 + 0.5, ((float_dat)sss_leaves) / 255.0);

            S_CLR = SetTexture(clr_tex, filter_clr, tex_tile, tex_tile, FALSE);

            if(!static_on)
            {
                MarkStencilDynamic();
            }

            VertexShader()
            {
                use Instancing();

                hlsl()
                {

                    #include <master_new.hlsl>
                    // #if defined(D_WIND_BEND_ON)
                        // #include <wind.hlsl>
                    // #endif

                    void main()
                    {
                        float4 pos_ms = Decode_Pos(I_POS_MS);

                        float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);

                        // #if defined(D_WIND_BEND_ON)
                            // float3 pivot_ws = float3(MODEL_XFORM_4x3[0].w, MODEL_XFORM_4x3[1].w, MODEL_XFORM_4x3[2].w);
                            // float3 pos2pivot_dir = pos_ws.xyz - pivot_ws;
                            // float pos2pivot_distance = length(pos2pivot_dir);

                            // float wind_power = GetWindDir_Power(pivot_ws, I_CLR_0.x);

                            // float3 wind_bend = GetWindDir_Force(wind_power) + GetWindOmni(pos_ws.xyz);
                            // pos2pivot_dir += wind_bend * I_CLR_0.y;

                            // float3 pos2pivot_dir_n = normalize(pos2pivot_dir);

                            // float3 nrm_ws = lerp(float3(0.0, 1.0, 0.0), pos2pivot_dir_n, I_CLR_0.y);

                            // pos_ws.xyz = pos2pivot_dir_n * pos2pivot_distance + pivot_ws;

                            // float3 nrm_es = Mul33(nrm_ws, VIEW_XFORM);
                            // float3 nrm_n_es = normalize(nrm_es);
                            // X_NRM_ES = nrm_n_es.xyzx * C_FACTORS.xxxy + C_FACTORS.xxxz;
                        // #endif


                        V_POS_OUT_TC = Pos_Out_WS(pos_ws);

                        X_UV_0 = Decode_UV(I_UV_0);

                        #if defined(D_OCCLUSION_ON)
                            X_OCCLUSION = C_FACTORS.wy * I_CLR_0.w;
                        #endif
                    }
                }
            }

            PixelShader()
            {
				hlsl()
                {
					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

                    #include <master_new.hlsl>

                    void main()
                    {
                        O_DIF = Sample(S_CLR, X_UV_0);

                        clip(O_DIF.w - 0.25);

                        #if defined(D_OCCLUSION_ON)
                            O_DIF *= X_OCCLUSION.xxxy;
                        #else
                            O_DIF *= C_FACTORS.wwwy;
                        #endif
						O_SPC = O_DIF * float4(0.0, 0.0, 0.0, 1.0);
                        // #if defined(D_WIND_BEND_ON)
                            // O_NRM = X_NRM_ES;
                        // #else
                            O_NRM = C_UP_DIR__MID;
                        //#endif
                    }
                }
            }
        }
        if(cast_shadows)
        {
            att_standard shadow_params = new att_standard();

            shadow_params.clr_0_tex = clr_tex;
            shadow_params.tex_tile = tex_tile;
            // shadow_params.wind_bend_on = wind_bend_on;
            shadow_params.technique = "zfill";

            depth_pass dpt = new depth_pass(this);
            dpt.setup(shadow_params);
        }
    }
}
