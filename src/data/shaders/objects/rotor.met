//new

using engineflags;
using settemplates;
using depth_pass;
using attribs;

template
{
	category Basic
	{
		class Main
		{
			string_dat clr_tex = "rotor_def.dds" : editor(ImageFileNameEditor), display(Color texture);
			float_dat rotation_speed = 5000.0: display(Rotation speed);
		}
	}
	category Advanced
	{
		class Shadows
		{
			bool_dat cast_shadows = FALSE : display(Cast shadows enabled);
		}
	}
	templatebody()
	{
		extern float_dat TIME;
		mtx_dat uv_0_xform = rotate(0.0, 0.0, rotation_speed * TIME);
		tech("trn_back")
		{
			Cull(NONE);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, ZERO, ONE);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, ZERO, ONE, 1);
			DepthFunc(LEQUAL, FALSE);

			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");

			X_UV_0 = SetTexcoord2();

			Output O_RT0 = new OutputFLOAT4("COLOR0");
			Output O_RT1 = new OutputFLOAT4("COLOR1");

			C_UV_0_XFM = SetConst(uv_0_xform);

			S_CLR = SetTexture(clr_tex, LINEAR_MIP_POINT, MIRROR, MIRROR, TRUE);

			X_SCATTERING_EXT = SetTexcoord3();
			X_SCATTERING_INS = SetTexcoord3();

			extern vec3_dat v_pp_sun_scattering_dir;
			C_SUN_SCATTERING_DIR = SetConst(v_pp_sun_scattering_dir);

			VertexShader()
			{
				use Instancing();

				hlsl()
				{
					#include <master_new.hlsl>
					#include <fog.hlsl>

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_MS);
						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);

						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						float2 uv_0 = Decode_UV(I_UV_0);
						X_UV_0.x = dot(uv_0, C_UV_0_XFM[0].xy);
						X_UV_0.y = dot(uv_0, C_UV_0_XFM[1].xy);

						float3 cam_dir_ws = pos_ws.xyz - CAMERA_POS_WS.xyz;
						float cam_dir_length = length(cam_dir_ws);
						X_SCATTERING_EXT = Scattering_Ext(cam_dir_length);
						X_SCATTERING_INS = Scattering_Ins(X_SCATTERING_EXT, normalize(cam_dir_ws), C_SUN_SCATTERING_DIR);
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
					#include <master_new.hlsl>

					void main()
					{
						O_RT0 = Sample(S_CLR, X_UV_0);
						O_RT0.xyz = O_RT0.xyz * X_SCATTERING_EXT + X_SCATTERING_INS;
						O_RT1 = O_RT0.wwww * float4(0.0, 0.0, 0.0, 1.0);
					}
				}
			}
		}
		if(cast_shadows)
		{
			att_standard shadow_params = new att_standard();

			shadow_params.clr_0_tex = clr_tex;
			shadow_params.tex_tile = MIRROR;
			shadow_params.technique = "zfill";
			shadow_params.uv_0_xform_on = TRUE;
			shadow_params.uv_0_xform = uv_0_xform;

			depth_pass dpt = new depth_pass(this);
			dpt.setup(shadow_params);
		}
	}
}
