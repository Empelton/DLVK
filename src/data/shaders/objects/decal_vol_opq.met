//new

using engineflags;
using settemplates;
using attribs;
using tmu;

public class Volume_Variants : StringVariantConv
{
	public static object[] Data = { "\"Sphere\"", "\"Box\"", "\"Cylinder\"" };
	public override object[] GetData() { return Data; }
}

public class Geom_Variants : StringVariantConv
{
	public static object[] Data = { "\"Dynamic\"", "\"Static\"", "\"All\"" };
	public override object[] GetData() { return Data; }
}


template
{
	category Basic
	{
		class Main
		{
			string_dat clr_0_tex = "" : editor(ImageFileNameEditor), display(Base color texture);
			string_dat nrm_0_tex = "" : editor(ImageFileNameEditor), display(Base normal texture);
			float_dat nrm_factor = 1.0 : display(Background normals weight);
			float_dat nrm_src_factor = 1.0 : display(Source normals weight);
			float_dat rgh = 0.5 : display(Roughness value);
			bool_dat fade_on = TRUE : display(Depth fade enabled);
			string_dat volume_type = "Sphere" : converter(Volume_Variants), display(Volume type);
			string_dat geom_type = "Dynamic" : converter(Geom_Variants), display(Affects geometry);
		}
	}

	templatebody()
	{
		bool_dat nrm_on = (nrm_factor < 1.0);
		string_dat technique = If(nrm_on, "opq_clr_nrm", "opq_clr");
		tech(technique)
		{
			Cull(CW);
			DepthFunc(LEQUAL, FALSE);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, BLEND_FACTOR, INV_SRC_ALPHA, 0);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, BLEND_FACTOR, INV_SRC_ALPHA, 1);
			BlendFactor(vec(1.0, 1.0, 1.0, rgh));

			if(geom_type != "All")
			{
				int_dat i_stencil = If((geom_type == "Dynamic"), i_stencil_background, i_stencil_dynamic);
				StencilOp(STENCIL_KEEP, STENCIL_KEEP, STENCIL_KEEP);
				StencilFunc(NOTEQUAL, i_stencil, 255);
				StencilWriteMask(i_stencil);
				StencilEnable(true);
			}


			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_CLR_USR = new InputFloat4("COLOR_USER");

			X_CLR_USR_0 = SetTexcoord4();
			X_INVMODELVIEW_XFORM = SetTexcoord4Array(3, "float");

			use PP_DEPTH_TMU();

			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");

			if(nrm_on)
			{
                Define("D_NRM_ON", 1);
                C_NRM_DST = SetConst(1.0 - nrm_factor);
				C_NRM_SRC_SCALE_BIAS = SetConst(2.0 * nrm_src_factor, 0.0, -nrm_src_factor, 0.5);
				BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, BLEND_FACTOR, INV_SRC_ALPHA, 2);
				ColorFunc(TRUE, TRUE, TRUE, TRUE, 0);
				ColorFunc(TRUE, TRUE, TRUE, TRUE, 1);
				ColorFunc(TRUE, TRUE, TRUE, FALSE, 2);
				Output O_NRM = new OutputFLOAT4("COLOR2");
				if(nrm_0_tex != "")
				{
					S_NRM_0 = SetTexture2D(nrm_0_tex, LINEAR_NO_MIP, CLAMP, CLAMP, FALSE);
					X_MODELVIEW_XFORM = SetTexcoord3Array(3, "float");
				}
				else { X_NRM_0 = SetTexcoord3(); }
			}

			if(fade_on)
			{
				Define("D_DEPTH_FADE_ON", 1);
			}

			if(clr_0_tex != "")
			{
				S_CLR_0 = SetTexture2D(clr_0_tex, LINEAR_NO_MIP, CLAMP, CLAMP, FALSE);
			}

			if(volume_type == "Box")
			{
				Define("D_VOLUME_BOX_ON", 1);
			}
			else if(volume_type == "Cylinder")
			{
				Define("D_VOLUME_CYLINDER_ON", 1);
			}

			VertexShader()
			{
				use Instancing();

				hlsl()
				{

					#include <master_new.hlsl>

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_MS);

						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);

						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						X_CLR_USR_0 = Decode_Usr(I_CLR_USR);

						float4 m_model[3];
						m_model[0] = MODEL_XFORM_4x3[0];
						m_model[1] = MODEL_XFORM_4x3[1];
						m_model[2] = MODEL_XFORM_4x3[2];

						float4 m_modelview[3];
						MulMTX(m_model, VIEW_XFORM, m_modelview);

						float4 m_invmodelview[3];
						InvertMTX(m_modelview, m_invmodelview);

						X_INVMODELVIEW_XFORM[0] = m_invmodelview[0];
						X_INVMODELVIEW_XFORM[1] = m_invmodelview[1];
						X_INVMODELVIEW_XFORM[2] = m_invmodelview[2];

                        #if defined(D_NRM_ON)
							#if defined(S_NRM_0)
								X_MODELVIEW_XFORM[0] = m_modelview[0].xyz;
								X_MODELVIEW_XFORM[1] = m_modelview[1].xyz;
								X_MODELVIEW_XFORM[2] = m_modelview[2].xyz;
							#else
								float3 nrm_ms = float3(0.0, 1.0, 0.0);
								float3 nrm_ws = Mul33(nrm_ms, MODEL_XFORM_4x3);
								float3 nrm_es = Mul33(nrm_ws, VIEW_XFORM);
								X_NRM_0 = normalize(nrm_es) * 0.5 + 0.5;
							#endif
						#endif
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
 					#if defined(SHADER_PATH_ORBIS) && defined(D_NRM_ON)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

					#include <master_new.hlsl>
					#include <position_cs.hlsl>
					#include <colorops.hlsl>

					void main()
					{
						O_SPC = X_CLR_USR_0;

						FLOAT2 uv_screen = UV_Screen(V_POS_SS_TC);
						float depth = Depth_Sample(uv_screen);

						float4 pos_cs = Pos_CS(depth, V_POS_SS_TC);
						float3 pos_ms = Mul43(pos_cs, X_INVMODELVIEW_XFORM);
						#if defined(S_CLR_0) || defined(S_NRM_0)
							FLOAT2 uv = saturate(pos_ms.xz * 0.5 + 0.5);
						#endif

						FLOAT ext;
						#if defined(D_VOLUME_BOX_ON)
							ext = min(min(abs(pos_ms.x), abs(pos_ms.y)), abs(pos_ms.z));
						#elif defined(D_VOLUME_CYLINDER_ON)
							ext = dot(pos_ms.xz, pos_ms.xz);
							ext = min(ext, abs(pos_ms.y));
						#else
							ext = dot(pos_ms, pos_ms);
						#endif
						ext = 1.0 - ext;
						clip(ext);

						#if defined(D_DEPTH_FADE_ON)
							O_SPC.w = saturate(O_SPC.w * sqrt(ext));
						#endif

						#if defined(S_CLR_0)
							O_SPC *= Sample(S_CLR_0, uv, 0.0);
							O_DIF = O_SPC;
							O_SPC.xyz = SwizzleXXX(Luminance(O_SPC.xyz) * 0.5);
						#endif
                        #if defined(D_NRM_ON)
							#if defined(S_NRM_0)
								FLOAT3 nrm_ms = Sample(S_NRM_0, uv, 0.0).aag * C_NRM_SRC_SCALE_BIAS.xyx + C_NRM_SRC_SCALE_BIAS.zwz;
								FLOAT3 nrm_es = Mul33(nrm_ms, X_MODELVIEW_XFORM);
								FLOAT3 nrm_n_es = normalize(nrm_es);
								#if defined(SHADER_PATH_ORBIS)
									O_NRM.xyz = nrm_n_es * -0.5 + 0.5;
								#else
									O_NRM.xyz = nrm_n_es * 0.5 + 0.5;
								#endif
							#else
								O_NRM.xyz = X_NRM_0;
							#endif
                            O_NRM.w = O_SPC.w * C_NRM_DST;
						#endif
					}
				}
			}
		}
	}
}
