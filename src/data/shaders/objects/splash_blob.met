//new

using engineflags;
using settemplates;

template
{
	category Main
	{
		class Basic
		{
			string_dat clr_tex = s_tex_def : editor(ImageFileNameEditor), display(Color);
			string_dat env_tex = s_tex_def : editor(ImageFileNameEditor), display(env);
			string_dat rfr_tex = s_tex_def : editor(ImageFileNameEditor), display(rfr);
			string_dat msk_tex = s_tex_def : editor(ImageFileNameEditor), display(msk);
			string_dat nrm_tex = s_tex_def : editor(ImageFileNameEditor), display(Normal);
			float_dat f_nrm_scale = 1.0 : editor(FloatSpinEditor), display(Normal Scale);
			vec3_dat v_col = vec( 1.0 , 1.0, 1.0 ): editor(ColorRGBEditor), display(ecie pecie 1);
			vec3_dat v_col_2 = vec( 1.0 , 1.0, 1.0 ): editor(ColorRGBEditor), display(ecie pecie 2);
		}
	}

    category Advanced
    {
        class Geometry
        {
            bool_dat static_on = FALSE;
        }
        //class Gamma
        //{
        //    bool_dat gamma_correct_on = false;
        //}
    }

	templatebody()
	{
		tech("opq")
		{
			use SetupMaterial();
			Cull(CW);
			DepthFunc(LEQUAL, TRUE);

			Input I_POS_0 = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_CLR_USR = new InputFloat4("COLOR_USER");
			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");
			Output O_NRM = new OutputFLOAT4("COLOR2");

			X_UV_0 = SetTexcoord2();
			X_NRM = SetTexcoord3();
			X_BNR = __none;
			X_TNG = __none;
			X_POS_CS = SetTexcoord3("FLOAT");
			X_CLR_USR_X = SetTexcoord();
			C_NRM_SCALE = SetConst(f_nrm_scale);
			extern float_dat TIME;
            C_V_CLR = SetConst(v_col);
            C_V_CLR_2 = SetConst(v_col_2);

			if(clr_tex != s_tex_def)
			{
				S_CLR = SetTexture(clr_tex);
				Define ("D_CLR_ON", 1);
			}

				S_ENV = SetTextureCUBE(env_tex);
				S_RFR = SetTexture(rfr_tex);
				Define ("D_ENV_ON", 1);

			if(nrm_tex != s_tex_def)
			{
				S_NRM = SetTexture(nrm_tex);
				S_MSK = SetTexture(msk_tex);

				Input I_TNG_0 = new InputFloat4("TANGENT");

				X_BNR = SetTexcoord3();
				X_TNG = SetTexcoord3();

				Define("D_NRM_ON", 1);
			}

            if(!static_on)
            {
                MarkStencilDynamic();
            }

			VertexShader()
			{
				use Instancing();
				hlsl()
				{

					#include <master_new.hlsl>

					void main()
					{
						float4 usr_1 ;
						float4 usr_0 = Decode_Usr(I_CLR_USR, usr_1);

						X_UV_0 = Decode_UV(I_UV_0);
						X_CLR_USR_X = usr_0.b;

						float ang = 0.2;
						float4 pos_ms = Decode_Pos(I_POS_0);

						float3 pos_ms_b = pos_ms.xyz;
						pos_ms_b.x = cos(ang)*pos_ms.x - sin(ang)* pos_ms.y;
						pos_ms_b.y = sin(ang)*pos_ms.x + cos(ang)* pos_ms.y;

						float3 pos_ms_t = pos_ms.xyz;
						pos_ms_t.z = cos(ang)*pos_ms.z - sin(ang)* pos_ms.y;
						pos_ms_t.y = sin(ang)*pos_ms.z + cos(ang)* pos_ms.y;
						float cut_val_y = -0.5 * usr_1.a;
						float cut_val_x = -0.5 * usr_0.a;
//
//						float frac_time = frac(-TIME*0.5);
						float frac_time = usr_0.r;
						float time_val_1 = (frac_time * 3.1415 * 8.0 );
						float time_val_2 = (frac_time );
						float blob_0_val = 0.4  ;
						float blob_1_val = 0.03 * usr_0.g;

						float blob_msk_0 = saturate(length(pos_ms.xz)*length(pos_ms.xz) * 4.0 );
						float blob_msk = (pos_ms.y > cut_val_y) ? 1.0 - blob_msk_0 : 0.0;
						pos_ms.xyz *= usr_1.xyz;
						pos_ms.x +=blob_msk * (sin(time_val_1)) * blob_0_val * (time_val_2);
						pos_ms.y += pos_ms.x *  blob_msk * (sin(time_val_1)) * blob_0_val * (time_val_2);
						pos_ms.y += sin(TIME*10 + pos_ms.x*10 + sin(TIME +pos_ms.z*10) )*blob_1_val;
						pos_ms.x += sin(TIME*12 + pos_ms.z*12.4 + sin(TIME*1.7 +pos_ms.y*12) )*blob_1_val;
						pos_ms.z += sin(TIME*13.5 + pos_ms.y*11 + sin(TIME*2.3 +pos_ms.x*7) )*blob_1_val;
						pos_ms.y = ( pos_ms.y > cut_val_y ) ? pos_ms.y : cut_val_y ;
						pos_ms.x = ( pos_ms.x > cut_val_x ) ? pos_ms.x : cut_val_x ;

						float blob_msk_0_b = saturate(length(pos_ms_b.xz)*length(pos_ms_b.xz) * 4.0);
						float blob_msk_b = (pos_ms.y > 0.0) ? 1.0 - blob_msk_0_b : 0.0;
						pos_ms_b.xyz *= usr_1.xyz;
						pos_ms_b.x += blob_msk_b * (sin(time_val_1)) * blob_0_val * (time_val_2);
						pos_ms_b.y += pos_ms_b.x *  blob_msk_b * (sin(time_val_1)) * blob_0_val * (time_val_2);
						pos_ms_b.y += sin(TIME*10 + pos_ms_b.x*10 + sin(TIME +pos_ms_b.z*10) )*blob_1_val;
						pos_ms_b.x += sin(TIME*12 + pos_ms_b.z*12.4 + sin(TIME*1.7 +pos_ms_b.y*12) )*blob_1_val;
						pos_ms_b.z += sin(TIME*13.5 + pos_ms_b.y*11 + sin(TIME*2.3 +pos_ms_b.x*7) )*blob_1_val;
						pos_ms_b.y = ( pos_ms_b.y > cut_val_y ) ? pos_ms_b.y : cut_val_y ;
						pos_ms_b.x = ( pos_ms_b.x > cut_val_x ) ? pos_ms_b.x : cut_val_x ;

						float blob_msk_0_t = saturate(length(pos_ms_t.xz)*length(pos_ms_t.xz) * 4.0 );
						float blob_msk_t = (pos_ms.y > 0.0) ? 1.0 - blob_msk_0_t : 0.0;
						pos_ms_t.xyz *= usr_1.xyz;
						pos_ms_t.x +=blob_msk_t * (sin(time_val_1 )) * blob_0_val * (time_val_2);
						pos_ms_t.y += pos_ms_t.x *  blob_msk_t *(sin(time_val_1)) * blob_0_val * (time_val_2);
						pos_ms_t.y += sin(TIME*10 + pos_ms_t.x*10 + sin(TIME +pos_ms_t.z*10) )*blob_1_val;
						pos_ms_t.x += sin(TIME*12 + pos_ms_t.z*12.4 + sin(TIME*1.7 +pos_ms_t.y*12) )*blob_1_val;
						pos_ms_t.z += sin(TIME*13.5 + pos_ms_t.y*11 + sin(TIME*2.3 +pos_ms_t.x*7) )*blob_1_val;
						pos_ms_t.y = ( pos_ms_t.y > cut_val_y ) ? pos_ms_t.y : cut_val_y ;
						pos_ms_t.x = ( pos_ms_t.x > cut_val_x ) ? pos_ms_t.x : cut_val_x ;

						float3 v_bnr = normalize(pos_ms.xyz - pos_ms_b);
						float3 v_tng = normalize(pos_ms.xyz - pos_ms_t);

						float3 new_nrm = cross(v_bnr,v_tng)  ;

						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						float3 nrm_ms = (pos_ms.y < 0.0) ? new_nrm : - new_nrm;


						float3 nrm_ws = Mul33(nrm_ms, MODEL_XFORM_4x3);
						float3 nrm_es = Mul33(nrm_ws, VIEW_XFORM);
						float3 nrm_n_es = normalize(nrm_es);
						X_NRM = nrm_n_es;

						#if defined (D_NRM_ON)

							float3 tng_ws = Mul33(I_TNG_0.xyz, MODEL_XFORM_4x3); //
							float3 tng_es = Mul33(tng_ws, VIEW_XFORM); //
							float3 tng_n_es = normalize(tng_es);
							X_TNG = tng_n_es;

							float3 bnr_n_es = cross(nrm_n_es, tng_n_es); //
							bnr_n_es *= I_TNG_0.w;
							X_BNR = bnr_n_es;

						#endif

						X_POS_CS = Mul_Pos(pos_ws, VIEW_XFORM).xyz;
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

					#include <master_new.hlsl>

					void main()
					{


						#if defined(D_NRM_ON)
							FLOAT3 nrm = SwizzleXXX(1.0);
							FLOAT3 M_ES2TS[3];
							M_ES2TS[0] = X_TNG;
							M_ES2TS[1] = X_BNR;
							M_ES2TS[2] = X_NRM;

							nrm.xy = Sample(S_NRM, X_UV_0).ag * 2.0 - 1.0;
							nrm.xy *= C_NRM_SCALE;
							FLOAT3 nrm_es = Mul33T(nrm, M_ES2TS);
						#else
							FLOAT3 nrm_es = X_NRM;
						#endif


							FLOAT3 cam_dir_n = normalize(X_POS_CS);
							FLOAT fresnel = saturate(dot(-nrm_es, cam_dir_n));
							FLOAT3 rfl_cs = reflect (cam_dir_n, nrm_es);
							FLOAT3 rfl_ws = Mul33(rfl_cs, INVVIEW_XFORM);
							FLOAT3 v_env = SampleCUBE_h3(S_ENV, rfl_ws, 0.0);

						FLOAT3 nrm_n_cs_4_rfl = normalize(rfl_ws.xyz * 3.0 - 1.5);
						FLOAT2 rfr_uv = nrm_n_cs_4_rfl.xy * 0.8 + X_UV_0;
						FLOAT2 rfr_uv2 = nrm_n_cs_4_rfl.xy  * 0.2 - X_POS_CS.xy * 1.3+ float2( 0.0, TIME * 1.5 );

						O_NRM.xyz = nrm_es * 0.5 + 0.5;
                        O_NRM.w = 1.0;



						#if defined(D_CLR_ON)
							FLOAT4 clr = Sample(S_CLR, X_UV_0);
                            clr.xyz *=lerp(C_V_CLR, C_V_CLR_2, X_CLR_USR_X)  ;

							FLOAT clr_b = (Sample(S_MSK, rfr_uv2).g -0.4)*0.6;
							clr.xyz += clr_b *  X_CLR_USR_X;
							FLOAT4 clr_rfr = Sample(S_RFR, rfr_uv);
							O_DIF.xyz = lerp( clr_rfr.xyz , clr.xyz ,  saturate((fresnel) * 1.5) *0.8+0.2);
							O_DIF.xyz = lerp( v_env , O_DIF.xyz,  0.8 );


							O_DIF.a = 1.0;
						#else
                            O_DIF.xyz = C_V_CLR ;
							O_DIF.xyz = lerp( v_env , O_DIF.xyz,  0.8 );
							O_DIF.a = 1.0;
						#endif
						O_SPC = O_DIF * float4(0.0, 0.0, 0.0, 1.0);
					}
				}
			}
		}
	}
}
