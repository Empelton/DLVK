//new

using engineflags;
using settemplates;

template
{
	category Main
	{
		class Basic
		{
			string_dat clr_tex = s_tex_def : editor(ImageFileNameEditor), display(Color);
			bool_dat clip_on = FALSE : display(Alphatest enabled);

			float_dat p_scale = 1.0 : editor(FloatSpinEditor), display(particle scale);
			float_dat noise_h = 4.0 : editor(FloatSpinEditor), display(noise h);
			float_dat noise_a = 0.2 : editor(FloatSpinEditor), display(noise a);
			float_dat noise_c = 1.2 : editor(FloatSpinEditor), display(noise c);
		}
	}

	templatebody()
	{
		platform("*", "none; instancing");

		tech("opq")
		{
			use SetupMaterial();
			Cull(NONE);
			DepthFunc(LEQUAL, TRUE);
			extern float_dat f_pp_wind_offset;
			extern float_dat TIME;

			Input I_POS_0 = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_NRM_0 = new InputFloat3("NORMAL0");
			Input I_SIDE = new InputVFACE();

			Output O_CLR = new OutputFLOAT4("COLOR0");
			Output O_NRM = new OutputFLOAT4("COLOR1");

			X_UV_0 = SetTexcoord2();
			X_NRM = SetTexcoord3();

			C_SPEED_FACTOR_F0 = SetConst( f_pp_wind_offset);
			C_SPEED_FACTOR_F1 = SetConst( f_pp_wind_offset * 1, f_pp_wind_offset * 1 + 0.25, f_pp_wind_offset *  1.25 + 0.5 , f_pp_wind_offset *  1.25 + 0.75);
			C_SPEED_FACTOR_F2 = SetConst( f_pp_wind_offset * 3.45);

			Define("D_P_SCALE", p_scale );
			Define("D_NOISE_H", noise_h );
			Define("D_NOISE_A", noise_a );
			Define("D_NOISE_C", noise_c );
			Define("MID", mat_dielectric_min / 255.0 );

			if(clr_tex != s_tex_def)
			{
				S_CLR = SetTexture(clr_tex);
				Define ("D_CLR_ON", 1);
			}

			if(clip_on)
			{
				Define("D_CLIP_ON", 1);
			}

			VertexShader()
			{
				use Instancing();
				hlsl()
				{

					#include <master_new.hlsl>
					CONST_FLOAT f_wind_power;
					CONST_FLOAT f_pp_wind_noise;
					CONST_FLOAT4 v_pp_wind_2d_xform;
					CONST_FLOAT4 v_pp_wind_params_2; //temp
					CONST_FLOAT4 v_pp_wind_params_3;
					CONST_FLOAT3 v_wind_omni_pos;

					void main()
					{
						float4 pos_ms = Decode_Pos(I_POS_0);
						float delay  = pos_ms.y *  1337.3421;

						float3 scale_vec_x_ms = float3(1,0,0);
						float3 scale_vec_y_ms = float3(0,1,0);
						float3 scale_vec_z_ms = float3(0,0,1);
						float3 scale_vec_x_ws = Mul33(scale_vec_x_ms, MODEL_XFORM_4x3);
						float3 scale_vec_y_ws = Mul33(scale_vec_y_ms, MODEL_XFORM_4x3);
						float3 scale_vec_z_ws = Mul33(scale_vec_z_ms, MODEL_XFORM_4x3);
						float scale_x_val = length(scale_vec_x_ws);
						float scale_y_val = length(scale_vec_y_ws);
						float scale_z_val = length(scale_vec_z_ws);
						float3 scale_xyz_val = float3(scale_x_val,scale_y_val,scale_z_val);

						// obliczanie obrotu
						float4 rot_pos_ms;
						rot_pos_ms = (smoothstep(0.0, 1.0 , abs( frac( C_SPEED_FACTOR_F1 + delay )- 0.5 ) * 2.0 ) * 2.0 - 1.0);

						float2 wind_dir_space;
						wind_dir_space.x = dot(-pos_ms.zx, rot_pos_ms.xy * float2(1,-1));
						wind_dir_space.y = dot(pos_ms.zx, rot_pos_ms.yx);
						pos_ms.xz = wind_dir_space;

						wind_dir_space.x = dot(-pos_ms.yx, rot_pos_ms.zw * float2(1,-1));
						wind_dir_space.y = dot(pos_ms.yx, rot_pos_ms.wz);
						pos_ms.xy = wind_dir_space;

						pos_ms.xyz *= D_P_SCALE;
						pos_ms.xyz *= 1/scale_xyz_val;

						float noise_h = D_NOISE_H;
						float noise_a = D_NOISE_A;
						float noise_c = D_NOISE_C;

						float3 noise_w = float3(scale_x_val,scale_y_val,scale_z_val );  // zakres / skala

						float3 wind_direction_vec_ws = v_pp_wind_2d_xform.xwy; // t0
						float3 wind_direction_vec_ms = normalize((Mul33T(wind_direction_vec_ws,MODEL_XFORM_4x3))   /normalize(scale_xyz_val ))*10 * f_wind_power;

						float3 nose_x_f = float3( 2.58, 1.17, 0.89);
						float3 nose_y_f = float3( 2.32, 1.23, 0.93);
						float3 nose_z_f = float3( 2.65, 1.19, 0.87);

						float3 noise_x = smoothstep(0.0, 1.0, abs( frac(nose_x_f * noise_a * C_SPEED_FACTOR_F0 + delay * 1.234) - 0.5)*2) * noise_h  * float3(1,2,4.0);
						float3 noise_y = smoothstep(0.0, 1.0, abs( frac(nose_y_f * noise_a * C_SPEED_FACTOR_F0 + delay * 2.542) - 0.5)*2) * noise_h  * float3(1,2,4.0);
						float3 noise_z = smoothstep(0.0, 1.0, abs( frac(nose_z_f * noise_a * C_SPEED_FACTOR_F0 + delay * 1.983) - 0.5)*2) * noise_h  * float3(1,2,4.0);

						float noise_s_x = (noise_c*(C_SPEED_FACTOR_F0 + delay *25.14) + wind_direction_vec_ms.x*C_SPEED_FACTOR_F0+ (noise_x.x + noise_x.y +noise_x.z) * noise_c);
						float noise_s_y = (noise_c*(C_SPEED_FACTOR_F0 + delay *21.34)+ (noise_y.x + noise_y.y +noise_y.z) * noise_c);
						float noise_s_z = (noise_c*(C_SPEED_FACTOR_F0 + delay* 15.23) + wind_direction_vec_ms.z*C_SPEED_FACTOR_F0+ (noise_z.x + noise_z.y +noise_z.z) * noise_c);

						float3 noise_s = float3(noise_s_x,noise_s_y,noise_s_z);
						float3 noise = ((frac(noise_s/noise_w) * noise_w * 2 - noise_w) )/noise_w;

						float scale_f = 0.1;
						float scale_ms = saturate((1-abs(noise.x) )* scale_x_val*scale_f);
						scale_ms = min( scale_ms,saturate((1-abs(noise.y)) * scale_y_val * scale_f) );
						scale_ms = min( scale_ms,saturate((1-abs(noise.z)) * scale_z_val * scale_f) );

						pos_ms.xyz *= scale_ms;
						pos_ms.xyz += noise ;

						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3)  ;
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						X_UV_0 = Decode_UV(I_UV_0);

						float2 wind_dir_nrm;
						wind_dir_nrm.x = dot(-I_NRM_0.zx, rot_pos_ms.xy * float2(1,-1));
						wind_dir_nrm.y = dot(I_NRM_0.zx, rot_pos_ms.yx);
						I_NRM_0.xz = wind_dir_nrm;
						wind_dir_nrm.x = dot(-I_NRM_0.yx, rot_pos_ms.zw * float2(1,-1));
						wind_dir_nrm.y = dot(I_NRM_0.yx, rot_pos_ms.wz);
						I_NRM_0.xy = wind_dir_nrm;

						float3 nrm_ws = Mul33(I_NRM_0, MODEL_XFORM_4x3);
						float3 nrm_es = Mul33(nrm_ws, VIEW_XFORM);
						float3 nrm_n_es = normalize(nrm_es);

						X_NRM = nrm_n_es;
					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif

					#include <master_new.hlsl>

					void main()
					{

						#if defined(D_CLR_ON)

							FLOAT4 clr = Sample(S_CLR, X_UV_0  );
							O_CLR = clr;
							#if defined(D_CLIP_ON)
								clip(O_CLR.w - 0.25);
							#endif
							O_CLR.a = saturate(clr.a * 2 - 1);
						#else
							O_CLR = FLOAT4(0.015, 0.4, 0.9, 1);
						#endif

						FLOAT3 nrm_es = I_SIDE ? X_NRM : -X_NRM;
						O_NRM.xyz = nrm_es * 0.5 + 0.5;
						O_NRM.w = MID;
					}
				}
			}
		}
	}
}