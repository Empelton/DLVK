//new

using engineflags;
using settemplates;
using depth_pass;
using attribs;
using highlight_a;



public class Parallax_Variants : StringVariantConv
{
	public static object[] Data = { "\"Parallax\"", "\"Relief\"", "\"None\"" };
	public override object[] GetData() {return Data;}
}

public class StandardCullMode_Variants : IntVariantConv
{
    public static object[] Data = { "CULL_DEF", "NONE", "CW", "CCW" };
	public override object[] GetData() {return Data;}
};

public class MID_Variants : StringVariantConv
{
    public static object[] Data = { "\"Matte\"", "\"Plastic\"", "\"Metallic\"", "\"Glassy\"" };
	public override object[] GetData() {return Data;}
};

public class Channel_Variants : StringVariantConv
{
	public static object[] Data = { "\"\"", "\"r\"", "\"g\"", "\"b\"", "\"a\"" };
	public override object[] GetData() {return Data;}
};

public class Normals_Variants : StringVariantConv
{
	public static object[] Data = { "\"None\"", "\"Mesh\"", "\"Primary\"", "\"Secondary\"" };
	public override object[] GetData() {return Data;}
};


template
{

	//Material Presets ID
	public static int_dat mid_plastic = 0;
	public static int_dat mid_metallic = 1;
	public static int_dat mid_matte = 2;
	public static int_dat mid_glassy = 3;
	public static int_dat mid_emissive = 4;
	public static int_dat mid_skin = 5;
	public static int_dat mid_zombie_skin = 6;
	public static int_dat mid_zombie_grass = 7;
	public static int_dat mid_plastic_sss = 8;
	public static int_dat mid_metallic_sss = 9;
	public static int_dat mid_matte_sss = 10;
	public static int_dat mid_glassy_sss = 11;
	public static int_dat mid_leaves = 12;
	public static int_dat mid_water = 13;
	public static int_dat mid_blood_sss = 14;

	public static int_dat mid_plastic_sss_ems = 16;
	public static int_dat mid_metallic_sss_ems = 17;
	public static int_dat mid_matte_sss_ems = 18;
	public static int_dat mid_glassy_sss_ems = 19;
	public static int_dat mid_blood = 20;

	public static int_dat mid_plastic_ems = 24;
	public static int_dat mid_metallic_ems = 25;
	public static int_dat mid_matte_ems = 26;
	public static int_dat mid_glassy_ems = 27;
	public static int_dat mid_jelly = 28;

	public string TemplateCategory() { return "Objects"; }
	category Input
	{
		class Textures
		{
			string_dat idx_tex = "" : editor(ImageFileNameEditor), display(Indexes);
			string_dat grd_tex = "" : editor(ImageFileNameEditor), display(Gradients);
			string_dat grd_map_tex = "" : editor(ImageFileNameEditor), display(Gradient map);
			string_dat nrm_primary_tex = "" : editor(ImageFileNameEditor), display(Primary normals);
			string_dat nrm_secondary_tex = "" : editor(ImageFileNameEditor), display(Secondary normals);
		}

		class Transparency
		{
			bool_dat clip_on = FALSE : display(Alphatest enabled);
		}
		class Parallax
		{
			float_dat parallax_scale = 0.0 : display(Parallax scale);
		}
		// class Wind
		// {
			// bool_dat wind_bend_on = FALSE : display(Global bending enabled);
		// }
	}
	category O2E
	{
		class Odd2Even texture mask
		{
			string_dat o2e_tex_channel = "" : converter(Channel_Variants), display(Gradient map channel);
			float_dat o2e_tex_min = 0.0 : display(Mask minimum);
			float_dat o2e_tex_max = 1.0 : display(Mask maximum);
			float_dat o2e_tex_bias_scale = 0.0 : display(User bias scale);
		}
		class Odd2Even mesh mask
		{
			string_dat o2e_vc_channel = "" : converter(Channel_Variants), display(Vertex color channel);
			float_dat o2e_vc_min = 0.0 : display(Mask minimum);
			float_dat o2e_vc_max = 1.0 : display(Mask maximum);
			float_dat o2e_vc_bias_scale = 0.0 : display(User bias scale);
		}
		class Odd2Even direction mask
		{
			bool_dat o2e_dir_on = FALSE : display(Enabled);
			vec3_dat o2e_dir = vec(0.0, 1.0, 0.0) : display(Direction WS);
			float_dat o2e_dir_min = 0.0 : display(Mask minimum);
			float_dat o2e_dir_max = 1.0 : display(Mask maximum);
		}
		class Odd2Even height mask
		{
			bool_dat o2e_hgt_on = FALSE : display(Enabled);
			float_dat o2e_hgt_min = 0.0 : display(Zero level);
			float_dat o2e_hgt_max = 1.0 : display(One level);
		}
		class Odd2Even mask params
		{
			bool_dat o2e_sum_on = FALSE : display(Masks addition enabled);
		}
		class MID
		{
			float_dat o2e_mid_threshold = 0.5 : display(Odd 2 Even MID Threshold);
		}
	}
	category OE2M
	{
		class OddEven2Mip texture mask
		{
			string_dat oe2m_tex_channel = "" : converter(Channel_Variants), display(Gradient map channel);
			float_dat oe2m_tex_min = 0.0 : display(Mask minimum);
			float_dat oe2m_tex_max = 1.0 : display(Mask maximum);
			float_dat oe2m_tex_bias_scale = 0.0 : display(User bias scale);
		}
		class OddEven2Mip mesh mask
		{
			string_dat oe2m_vc_channel = "" : converter(Channel_Variants), display(Vertex color channel);
			float_dat oe2m_vc_min = 0.0 : display(Mask minimum);
			float_dat oe2m_vc_max = 1.0 : display(Mask maximum);
			float_dat oe2m_vc_bias_scale = 0.0 : display(User bias scale);
		}
		class OddEven2Mip direction mask
		{
			bool_dat oe2m_dir_on = FALSE : display(Enabled);
			vec3_dat oe2m_dir = vec(0.0, 1.0, 0.0) : display(Direction WS);
			float_dat oe2m_dir_min = 0.0 : display(Mask minimum);
			float_dat oe2m_dir_max = 1.0 : display(Mask maximum);
		}
		class OddEven2Mip height mask
		{
			bool_dat oe2m_hgt_on = FALSE : display(Enabled);
			float_dat oe2m_hgt_min = 0.0 : display(Zero level);
			float_dat oe2m_hgt_max = 1.0 : display(One level);
		}
		class OddEven2Mip mask params
		{
			bool_dat oe2m_sum_on = FALSE : display(Masks addition enabled);
		}
		class MID
		{
			float_dat oe2m_mid_threshold = 0.5 : display(OddEven 2 Mip MID Threshold);
		}
	}
	category Odd
	{
		class Idx channel
		{
			string_dat idx_odd_channel = "g" : converter(Channel_Variants);
		}
		class Normal
		{
			string_dat nrm_odd = "Primary" : converter(Normals_Variants), display(Normal);
			float_dat nrm_odd_factor = 1.0 : display(Normal scale);
		}
		class MID
		{
			string_dat mid_odd = "Matte" : converter(MID_Variants), display(Material ID);
			bool_dat sss_odd_on = FALSE : display(Sub-surface scattering enabled);
			bool_dat ems_odd_on = FALSE : display(Emissive enabled);
		}
	}
	category Even
	{
		class Idx channel
		{
			string_dat idx_even_channel = "g" : converter(Channel_Variants);
		}
		class Normal
		{
			string_dat nrm_even = "Primary" : converter(Normals_Variants), display(Normal);
			float_dat nrm_even_factor = 1.0 : display(Normal scale);
		}
		class MID
		{
			string_dat mid_even = "Matte" : converter(MID_Variants), display(Material ID);
			bool_dat sss_even_on = FALSE : display(Sub-surface scattering enabled);
			bool_dat ems_even_on = FALSE : display(Emissive enabled);
		}
	}
	category Mip
	{
		class Idx channel
		{
			string_dat idx_mip_channel = "g" : converter(Channel_Variants);
		}
		class Normal
		{
			string_dat nrm_mip = "Primary" : converter(Normals_Variants), display(Normal);
			float_dat nrm_mip_factor = 1.0 : display(Normal scale);
		}
		class MID
		{
			string_dat mid_mip = "Matte" : converter(MID_Variants), display(Material ID);
			bool_dat sss_mip_on = FALSE : display(Sub-surface scattering enabled);
			bool_dat ems_mip_on = FALSE : display(Emissive enabled);

		}
	}

	category Advanced
	{
		class Factors
		{
			float_dat nrm_factor = 1.0 : display(Global normals scale);
		}
		class Sampling
		{
			int_dat tex_tile = WRAP : converter(TexTile_Variants);
		}
		class Env
		{
			string_dat env_tex = "" : editor(ImageFileNameEditor), display(Alternative enviroment texture);
			int_dat env_usermap = -1 : display(Level enviroment usermap number);
			vec3_dat env_factor = vec(1.0, 1.0, 1.0) : editor(ColorRGBEditor), display(Env Factor);
			float_dat env_mask_min = 0.0 : display(Env Mask Minimum);
			float_dat env_mask_max = 1.0 : display(Env Mask Maximum);
			float_dat env_fresnel_min = 0.0 : display(Env Fresnel Mask Minimum);
			float_dat env_fresnel_max = 1.0 : display(Env Fresnel Mask Maximum);
			bool_dat env_fresnel_pow_on = FALSE : display(Env Fresnel Mask Powered);
			float_dat env_nrm_scale = 1.0 : display(Env Normal Scale);
		}
		class Highlight
		{
			bool_dat highlight_on = FALSE : display(Highlight enabled);
		}
		class Parallax params
		{
			string_dat parallax_low_end = "Parallax" : converter(Parallax_Variants), display(Low-end technique);
			string_dat parallax_high_end = "Relief" : converter(Parallax_Variants), display(High-end technique);
			float_dat parallax_mip = 0.0 : display(Parallax mipmap);
			int_dat relief_linear_steps = 5 : display(Relief linear search steps);
			int_dat relief_binary_steps = 3 : display(Relief binary search steps);
			float_dat relief_linear_mip = 0.0 : display(Relief linear search mipmap);
			float_dat relief_binary_mip = 0.0 : display(Relief binary search mipmap);
		}
		class Culling
		{
			int_dat culling = CULL_DEF : converter(StandardCullMode_Variants), display(Culling);
		}
		class Debug
		{
			bool_dat cast_shadows_on = FALSE;
			bool_dat zpass_on = FALSE;
		}

        class Geometry
        {
            bool_dat static_on = true;
        }
        //class Gamma
        //{
        //    bool_dat gamma_correct_on = false;
        //}

	}

	templatebody()
	{
		bool_dat grd_map_on = (grd_map_tex != "");
			//jest ustawiona tekstura z mapa zmian gradientow

		//sprawdzenie masek
		bool_dat o2e_tex_on = (o2e_tex_channel != "") & grd_map_on;
			//jest wybrany kanal z gradientmapy
			//i jest ustawiona gradientmapa

		bool_dat o2e_vc_on = (o2e_vc_channel != "");
			//jest wybrany kanal vertex coloru

		bool_dat o2e_on = o2e_tex_on | o2e_vc_on | o2e_dir_on | o2e_hgt_on;

		bool_dat oe2m_tex_on = (oe2m_tex_channel != "") & grd_map_on;
			//jest wybrany kanal z gradientmapy
			//i jest ustawiona gradientmapa

		bool_dat oe2m_vc_on = (oe2m_vc_channel != "");
			//jest wybrany kanal vertex coloru

		bool_dat oe2m_on = oe2m_tex_on | oe2m_vc_on | oe2m_dir_on | oe2m_hgt_on;

		//normalki
		bool_dat nrm_primary_on = (nrm_primary_tex != "");
			//glowna tekstura z normalnymi jest ustwiona

		bool_dat nrm_secondary_on = (nrm_secondary_tex != "");
			//dodatkowa tekstura z normalnymi jest ustwiona

		//sprawdzenie wykorzystania normalnych
		bool_dat nrm_odd_primary_on = ((nrm_odd == "Primary") & (nrm_odd_factor > 0.0) & (nrm_factor > 0.0));
		bool_dat nrm_odd_secondary_on = ((nrm_odd == "Secondary") & (nrm_odd_factor > 0.0) & (nrm_factor > 0.0));
		bool_dat nrm_odd_mesh_on = (nrm_odd == "Mesh");
		bool_dat nrm_odd_on = nrm_odd_mesh_on | nrm_odd_secondary_on | nrm_odd_primary_on;


		bool_dat nrm_even_primary_on = ((nrm_even == "Primary") & (nrm_even_factor > 0.0) & (nrm_factor > 0.0));
		bool_dat nrm_even_secondary_on = ((nrm_even == "Secondary") & (nrm_even_factor > 0.0) & (nrm_factor > 0.0));
		bool_dat nrm_even_mesh_on = (nrm_even == "Mesh");
		bool_dat nrm_even_on = nrm_even_mesh_on | nrm_even_secondary_on | nrm_even_primary_on;

		//wylaczenie jednej z normalek gdy sa obie i nie ma maski
		bool_dat nrm_odd_n_even_on = nrm_odd_on & nrm_even_on & o2e_on;
		nrm_even_on = nrm_odd_n_even_on | (!nrm_odd_on & nrm_even_on); //UWAGA! to musi byc przed nrm_odd_on
			//jest wlaczone tylko gdy jest maska o2e
				//i jest nrm_odd
			//lub gdy nie ma nrm_odd
			nrm_even_primary_on = nrm_even_primary_on & nrm_even_on;
			nrm_even_secondary_on = nrm_even_secondary_on & nrm_even_on;
			nrm_even_mesh_on = nrm_even_mesh_on & nrm_even_on;

		nrm_odd_on = nrm_odd_n_even_on | (nrm_odd_on & !nrm_even_on);
			nrm_odd_primary_on = nrm_odd_primary_on & nrm_odd_on;
			nrm_odd_secondary_on = nrm_odd_secondary_on & nrm_odd_on;
			nrm_odd_mesh_on = nrm_odd_mesh_on & nrm_odd_on;

		bool_dat nrm_oe_on = nrm_even_on | nrm_odd_on;

		bool_dat nrm_mip_primary_on = ((nrm_mip == "Primary") & (nrm_mip_factor > 0.0) & (nrm_factor > 0.0));
		bool_dat nrm_mip_secondary_on = ((nrm_mip == "Secondary") & (nrm_mip_factor > 0.0) & (nrm_factor > 0.0));
		bool_dat nrm_mip_mesh_on = (nrm_mip == "Mesh");
		bool_dat nrm_mip_on = nrm_mip_mesh_on | nrm_mip_secondary_on | nrm_mip_primary_on;

		bool_dat nrm_oe_n_mip_on = nrm_oe_on & nrm_mip_on & oe2m_on;
		nrm_mip_on = nrm_oe_n_mip_on | (!nrm_oe_on & nrm_mip_on);
			//jest wlaczone tylko gdy jest maska oe2m
				//i jest nrm_odd lub nrm_even
			//lub gdy nie ma ani nrm_odd, ani nrm_even
			nrm_mip_primary_on = nrm_mip_primary_on & nrm_mip_on;
			nrm_mip_secondary_on = nrm_mip_secondary_on & nrm_mip_on;
			nrm_mip_mesh_on = nrm_mip_mesh_on & nrm_mip_on;

		//wylaczenie niepotrzebnych tekstur
		nrm_primary_on = nrm_odd_primary_on | nrm_even_primary_on | nrm_mip_primary_on;
		nrm_secondary_on = nrm_odd_secondary_on | nrm_even_secondary_on | nrm_mip_secondary_on;
		bool_dat nrm_tex_on = nrm_primary_on | nrm_secondary_on;

		//sprawdzenie wykorzystania MID
		bool_dat mid_even_on = (mid_even != mid_odd) & o2e_on;
		bool_dat mid_mip_on = (mid_mip != mid_odd) & oe2m_on;

		//sprawdzenie koloru
		bool_dat idx_on = (idx_tex != "");

		bool_dat grd_on = (grd_tex != "") & idx_on;
			//jest ustawiona tekstura z gradientami
			//i jest ustawiona tekstura z indeksami

		bool_dat idx_odd_on = (idx_odd_channel != "") & idx_on;
		bool_dat idx_even_on = (idx_even_channel != "") & idx_on;

		bool_dat idx_odd_n_even_on = idx_odd_on & idx_even_on & o2e_on;
		idx_even_on = idx_odd_n_even_on | (!idx_even_on & idx_even_on);

		bool_dat idx_oe_on = idx_odd_on | idx_even_on;

		bool_dat idx_mip_on = (idx_mip_channel != "") & idx_on;
		bool_dat idx_oe_n_mip_on = idx_oe_on & idx_mip_on & oe2m_on;
		idx_mip_on = idx_oe_n_mip_on | (!idx_oe_on & idx_mip_on);

		grd_on = grd_on & (idx_oe_on | idx_mip_on);

		extern int_dat SHADER_PATH;
		bool_dat relief_he = (parallax_high_end == "Relief");
		bool_dat relief_le = (parallax_low_end == "Relief");
		bool_dat parallax_he =  (parallax_high_end == "Parallax");
		bool_dat parallax_le = (parallax_low_end == "Parallax");
		bool_dat relief_on = ((SHADER_PATH == SM50) & relief_he) | ((SHADER_PATH != SM50) & relief_le);
		bool_dat parallax_on = ((SHADER_PATH == SM50) & parallax_he) | ((SHADER_PATH != SM50) & parallax_le);

		bool_dat hgt_on = idx_on & (parallax_scale > 0.0) & (parallax_on | relief_on);
			//jest ustawiona tekstura, z ktorej mozna odczytac mape wysokosci
			//i jest wybrany jakis typ parallax mappingu

		//wylaczenie idx gdy nic z niego nie korzysta i jest ustawiony
		idx_on = hgt_on | grd_on;

		oe2m_on = oe2m_on & (idx_oe_n_mip_on | mid_mip_on | nrm_oe_n_mip_on);
			oe2m_tex_on = oe2m_tex_on & oe2m_on;
			oe2m_vc_on = oe2m_vc_on & oe2m_on;

		o2e_on = o2e_on & (idx_odd_n_even_on | mid_even_on | nrm_odd_n_even_on);
			o2e_tex_on = o2e_tex_on & o2e_on;
			o2e_vc_on = o2e_vc_on & o2e_on;

		grd_map_on = o2e_tex_on | oe2m_tex_on;

		bool_dat o2e_tex_bias_on = o2e_tex_on & (o2e_tex_bias_scale != 0.0);
		bool_dat o2e_vc_bias_on = o2e_vc_on & (o2e_vc_bias_scale != 0.0);
		bool_dat oe2m_tex_bias_on = oe2m_tex_on & (oe2m_tex_bias_scale != 0.0);
		bool_dat oe2m_vc_bias_on = oe2m_vc_on & (oe2m_vc_bias_scale != 0.0);


		//ustalamy co jest potrzebne w VS
		bool_dat uv_0_on = idx_on | nrm_tex_on;
		bool_dat tng_on = hgt_on | nrm_tex_on;
		bool_dat vc_on =  oe2m_vc_on | o2e_vc_on;
		bool_dat usr_clr_on = grd_on | o2e_tex_bias_on | o2e_vc_bias_on | oe2m_tex_bias_on | oe2m_vc_bias_on;

		bool_dat texkill_on = idx_on & clip_on;
		string_dat technique = If(texkill_on, s_tech_opq2, s_tech_opq);

		tech(technique)
		{
			int_dat cull = If(texkill_on, NONE, CW);
			cull = If((culling < 0), cull, culling);
			if(cull == NONE)
            {
                Input I_SIDE = new InputVFACE();
                Define("D_CULLING_NONE", 1);
            }
			Cull(cull);

			DepthFunc(LEQUAL, TRUE);

			AddLine("StencilMarker(); ");

			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_NRM_MS = new InputFloat3("NORMAL0");
			if(tng_on)
			{
				Input I_TNG_MS = new InputFloat4("TANGENT0");
				Define("TNG_ON", 1);
			}
			if(uv_0_on)
			{
				Input I_UV_0 = new InputFloat2("TEXCOORD0");
				X_UV_0 = SetTexcoord2("FLOAT");
			}
			if(vc_on)
			{
				Input I_CLR_0 = new InputFloat4("COLOR0");
			}
			if(usr_clr_on)
			{
				Input I_CLR_USR = new InputFloat4("COLOR_USER");
				Define("CLR_USR_ON", 1);
			}

			Output O_SPC = new OutputFLOAT4("COLOR0");
			Output O_DIF = new OutputFLOAT4("COLOR1");
			Output O_NRM = new OutputFLOAT4("COLOR2");

			float_dat grd_size_x = 32.0;
			float_dat grd_size_y = 32.0;

			if(grd_map_on)
			{
				Input I_UV_1 = new InputFloat2("TEXCOORD1");
				X_UV_1 = SetTexcoord2("FLOAT");
				S_GRD_MAP = SetTexture2D(grd_map_tex, LINEAR_MIP_LINEAR, WRAP, WRAP, FALSE);
			}

			extern mtx_dat VIEW_XFORM;
            C_GRD_MAP_V_SCALE = SetConst(1.0 / grd_size_y);
			if(o2e_on)
			{
				if(o2e_tex_on)
				{
					Define("D_O2E_TEX_CHANNEL", o2e_tex_channel);
					float_dat o2e_tex_mask_mul = 1.0 / (o2e_tex_max - o2e_tex_min);
					float_dat o2e_tex_mask_add = -o2e_tex_min * o2e_tex_mask_mul;
                    C_O2E_TEX_MASK_MUL = SetConst(o2e_tex_mask_mul);
                    C_O2E_TEX_MASK_ADD = SetConst(o2e_tex_mask_add);
					if(o2e_tex_bias_on)
					{
                        C_O2E_TEX_BIAS_SCALE = SetConst(-o2e_tex_bias_scale * o2e_tex_mask_mul);
						X_O2E_TEX_MASK_ADD = SetTexcoord("FLOAT");
					}
				}
				if(o2e_vc_on)
				{
					Define("D_O2E_VC_CHANNEL", o2e_vc_channel);
					float_dat o2e_vc_mask_mul = 1.0 / (o2e_vc_max - o2e_vc_min);
					float_dat o2e_vc_mask_add = -o2e_vc_min * o2e_vc_mask_mul;
                    C_O2E_VC_MASK_MUL = SetConst(o2e_vc_mask_mul);
                    C_O2E_VC_MASK_ADD = SetConst(o2e_vc_mask_add);
					X_O2E_VC_MASK = SetTexcoord("FLOAT");
                    if(o2e_vc_bias_on)
                    {
                        Define("D_O2E_VC_BIAS_SCALE_ON", 1);
                        C_O2E_VC_BIAS_SCALE = SetConst(o2e_vc_bias_scale);
				}
                }
				if(o2e_dir_on)
				{
					Define("D_O2E_DIR_ON", 1);
					vec3_dat o2e_dir_cs = mulv(VIEW_XFORM, o2e_dir);
					float_dat o2e_dir_cs_length = pow(dot(o2e_dir_cs, o2e_dir_cs), 0.5);
					vec3_dat o2e_dir_n_cs = o2e_dir_cs / o2e_dir_cs_length;
					C_O2E_DIR_N_CS = SetConst(o2e_dir_n_cs);

					float_dat o2e_dir_mask_mul = 1.0 / (o2e_dir_max - o2e_dir_min);
					float_dat o2e_dir_mask_add = -o2e_dir_min * o2e_dir_mask_mul;
                    C_O2E_DIR_MASK_MUL = SetConst(o2e_dir_mask_mul);
                    C_O2E_DIR_MASK_ADD = SetConst(o2e_dir_mask_add);
					if(!nrm_tex_on | nrm_even_primary_on | nrm_even_secondary_on | nrm_even_mesh_on) { X_O2E_DIR_MASK = SetTexcoord("FLOAT"); }
				}
				if(o2e_hgt_on)
				{
					float_dat o2e_hgt_mask_mul = 1.0 / (o2e_hgt_max - o2e_hgt_min);
					float_dat o2e_hgt_mask_add = -o2e_hgt_min * o2e_hgt_mask_mul;
                    C_O2E_HGT_MASK_MUL = SetConst(o2e_hgt_mask_mul);
                    C_O2E_HGT_MASK_ADD = SetConst(o2e_hgt_mask_add);
					X_O2E_HGT_MASK = SetTexcoord();
				}
				if(oe2m_sum_on)
				{
					Define("D_O2E_OP", "+");
					Define("D_O2E_INIT", "0.0");
				}
				else
				{
					Define("D_O2E_OP", "*");
					Define("D_O2E_INIT", "1.0");
				}
			}
			if(oe2m_on)
			{
				Define("D_OE2M_ON", 1);
				if(oe2m_tex_on)
				{
					Define("D_OE2M_TEX_CHANNEL", oe2m_tex_channel);
					float_dat oe2m_tex_mask_mul = 1.0 / (oe2m_tex_max - oe2m_tex_min);
					float_dat oe2m_tex_mask_add = -oe2m_tex_min * oe2m_tex_mask_mul;
                    C_OE2M_TEX_MASK_MUL = SetConst(oe2m_tex_mask_mul);
                    C_OE2M_TEX_MASK_ADD = SetConst(oe2m_tex_mask_add);
					if(oe2m_tex_bias_on)
					{
                        C_OE2M_TEX_BIAS_SCALE = SetConst(-oe2m_tex_bias_scale * oe2m_tex_mask_mul);
						X_OE2M_TEX_MASK_ADD = SetTexcoord("FLOAT");
					}
				}
				if(oe2m_vc_on)
				{
					Define("D_OE2M_VC_CHANNEL", oe2m_vc_channel);
					float_dat oe2m_vc_mask_mul = 1.0 / (oe2m_vc_max - oe2m_vc_min);
					float_dat oe2m_vc_mask_add = -oe2m_vc_min * oe2m_vc_mask_mul;
                    C_OE2M_VC_MASK_MUL = SetConst(oe2m_vc_mask_mul);
                    C_OE2M_VC_MASK_ADD = SetConst(oe2m_vc_mask_add);
					X_OE2M_VC_MASK = SetTexcoord("FLOAT");
                    if(oe2m_vc_bias_on)
                    {
                        Define("D_OE2M_VC_BIAS_SCALE_ON", 1);
                        C_OE2M_VC_BIAS_SCALE = SetConst(oe2m_vc_bias_scale);
				}
                }
				if(oe2m_dir_on)
				{
					Define("D_OE2M_DIR_ON", 1);
					vec3_dat oe2m_dir_cs = mulv(VIEW_XFORM, oe2m_dir);
					float_dat oe2m_dir_cs_length = pow(dot(oe2m_dir_cs, oe2m_dir_cs), 0.5);
					vec3_dat oe2m_dir_n_cs = oe2m_dir_cs / oe2m_dir_cs_length;
					C_OE2M_DIR_N_CS = SetConst(oe2m_dir_n_cs);

					float_dat oe2m_dir_mask_mul = 1.0 / (oe2m_dir_max - oe2m_dir_min);
					float_dat oe2m_dir_mask_add = -oe2m_dir_min * oe2m_dir_mask_mul;
                    C_OE2M_DIR_MASK_MUL = SetConst(oe2m_dir_mask_mul);
                    C_OE2M_DIR_MASK_ADD = SetConst(oe2m_dir_mask_add);
					if(!nrm_tex_on | nrm_mip_primary_on | nrm_mip_secondary_on | nrm_mip_mesh_on) { X_OE2M_DIR_MASK = SetTexcoord("FLOAT"); }
				}
				if(oe2m_hgt_on)
				{
					float_dat oe2m_hgt_mask_mul = 1.0 / (oe2m_hgt_max - oe2m_hgt_min);
					float_dat oe2m_hgt_mask_add = -oe2m_hgt_min * oe2m_hgt_mask_mul;
                    C_OE2M_HGT_MASK_MUL = SetConst(oe2m_hgt_mask_mul);
                    C_OE2M_HGT_MASK_ADD = SetConst(oe2m_hgt_mask_add);
					X_OE2M_HGT_MASK = SetTexcoord();
				}
				if(oe2m_sum_on)
				{
					Define("D_OE2M_OP", "+");
					Define("D_OE2M_INIT", "0.0");
				}
				else
				{
					Define("D_OE2M_OP", "*");
					Define("D_OE2M_INIT", "1.0");
				}
			}
float_dat mid_global = (float_dat)mat_dielectric / 255.0;
C_MID_GLOBAL = SetConst(mid_global);
			if(mid_odd == "Matte")
			{
				int_dat mid_odd_id = If(ems_odd_on & sss_odd_on, mid_matte_sss_ems, mid_matte);
				mid_odd_id = If(ems_odd_on & !sss_odd_on, mid_matte_ems, mid_odd_id);
				mid_odd_id = If(!ems_odd_on & sss_odd_on, mid_matte_sss, mid_odd_id);
                C_MID_ODD = SetConst(((float_dat)mid_odd_id) / 255.0);
			}
			if(mid_odd == "Plastic")
			{
				int_dat mid_odd_id = If(ems_odd_on & sss_odd_on, mid_plastic_sss_ems, mid_plastic);
				mid_odd_id = If(ems_odd_on & !sss_odd_on, mid_plastic_ems, mid_odd_id);
				mid_odd_id = If(!ems_odd_on & sss_odd_on, mid_plastic_sss, mid_odd_id);
                C_MID_ODD = SetConst(((float_dat)mid_odd_id) / 255.0);
			}
			if(mid_odd == "Metallic")
			{
				int_dat mid_odd_id = If(ems_odd_on & sss_odd_on, mid_metallic_sss_ems, mid_metallic);
				mid_odd_id = If(ems_odd_on & !sss_odd_on, mid_metallic_ems, mid_odd_id);
				mid_odd_id = If(!ems_odd_on & sss_odd_on, mid_metallic_sss, mid_odd_id);
                C_MID_ODD = SetConst(((float_dat)mid_odd_id) / 255.0);
			}
			if(mid_odd == "Glassy")
			{
				int_dat mid_odd_id = If(ems_odd_on & sss_odd_on, mid_glassy_sss_ems, mid_glassy);
				mid_odd_id = If(ems_odd_on & !sss_odd_on, mid_glassy_ems, mid_odd_id);
				mid_odd_id = If(!ems_odd_on & sss_odd_on, mid_glassy_sss, mid_odd_id);
                C_MID_ODD = SetConst(((float_dat)mid_odd_id) / 255.0);
			}

			if(mid_even_on)
			{
                C_O2E_MID_THRESHOLD = SetConst(o2e_mid_threshold);
				if(mid_even == "Matte")
				{
					int_dat mid_even_id = If(ems_even_on & sss_even_on, mid_matte_sss_ems, mid_matte);
					mid_even_id = If(ems_even_on & !sss_even_on, mid_matte_ems, mid_even_id);
					mid_even_id = If(!ems_even_on & sss_even_on, mid_matte_sss, mid_even_id);
                    Define("D_MID_EVEN_ON", 1);
                    C_MID_EVEN = SetConst(((float_dat)mid_even_id) / 255.0);
				}
				if(mid_even == "Plastic")
				{
					int_dat mid_even_id = If(ems_even_on & sss_even_on, mid_plastic_sss_ems, mid_plastic);
					mid_even_id = If(ems_even_on & !sss_even_on, mid_plastic_ems, mid_even_id);
					mid_even_id = If(!ems_even_on & sss_even_on, mid_plastic_sss, mid_even_id);
                    Define("D_MID_EVEN_ON", 1);
                    C_MID_EVEN = SetConst(((float_dat)mid_even_id) / 255.0);
				}
				if(mid_even == "Metallic")
				{
					int_dat mid_even_id = If(ems_even_on & sss_even_on, mid_metallic_sss_ems, mid_metallic);
					mid_even_id = If(ems_even_on & !sss_even_on, mid_metallic_ems, mid_even_id);
					mid_even_id = If(!ems_even_on & sss_even_on, mid_metallic_sss, mid_even_id);
                    Define("D_MID_EVEN_ON", 1);
                    C_MID_EVEN = SetConst(((float_dat)mid_even_id) / 255.0);
				}
				if(mid_even == "Glassy")
				{
					int_dat mid_even_id = If(ems_even_on & sss_even_on, mid_glassy_sss_ems, mid_glassy);
					mid_even_id = If(ems_even_on & !sss_even_on, mid_glassy_ems, mid_even_id);
					mid_even_id = If(!ems_even_on & sss_even_on, mid_glassy_sss, mid_even_id);
                    Define("D_MID_EVEN_ON", 1);
                    C_MID_EVEN = SetConst(((float_dat)mid_even_id) / 255.0);
				}
			}
			if(mid_mip_on)
			{
                C_OE2M_MID_THRESHOLD = SetConst(oe2m_mid_threshold);
				if(mid_mip == "Matte")
				{
					int_dat mid_mip_id = If(ems_mip_on & sss_mip_on, mid_matte_sss_ems, mid_matte);
					mid_mip_id = If(ems_mip_on & !sss_mip_on, mid_matte_ems, mid_mip_id);
					mid_mip_id = If(!ems_mip_on & sss_mip_on, mid_matte_sss, mid_mip_id);
                    Define("D_MID_MIP_ON", 1);
                    C_MID_MIP = SetConst(((float_dat)mid_mip_id) / 255.0);
				}
				if(mid_mip == "Plastic")
				{
					int_dat mid_mip_id = If(ems_mip_on & sss_mip_on, mid_plastic_sss_ems, mid_plastic);
					mid_mip_id = If(ems_mip_on & !sss_mip_on, mid_plastic_ems, mid_mip_id);
					mid_mip_id = If(!ems_mip_on & sss_mip_on, mid_plastic_sss, mid_mip_id);
                    Define("D_MID_MIP_ON", 1);
                    C_MID_MIP = SetConst(((float_dat)mid_mip_id) / 255.0);
				}
				if(mid_mip == "Metallic")
				{
					int_dat mid_mip_id = If(ems_mip_on & sss_mip_on, mid_metallic_sss_ems, mid_metallic);
					mid_mip_id = If(ems_mip_on & !sss_mip_on, mid_metallic_ems, mid_mip_id);
					mid_mip_id = If(!ems_mip_on & sss_mip_on, mid_metallic_sss, mid_mip_id);
                    Define("D_MID_MIP_ON", 1);
                    C_MID_MIP = SetConst(((float_dat)mid_mip_id) / 255.0);
				}
				if(mid_mip == "Glassy")
				{
					int_dat mid_mip_id = If(ems_mip_on & sss_mip_on, mid_glassy_sss_ems, mid_glassy);
					mid_mip_id = If(ems_mip_on & !sss_mip_on, mid_glassy_ems, mid_mip_id);
					mid_mip_id = If(!ems_mip_on & sss_mip_on, mid_glassy_sss, mid_mip_id);
                    Define("D_MID_MIP_ON", 1);
                    C_MID_MIP = SetConst(((float_dat)mid_mip_id) / 255.0);
				}
			}
			if(grd_on)
			{

				float_dat grd_v_scale = (255.0 / grd_size_y) * 2.0; // x2 - step by 2 lines

                C_GRD_U_SCALE = SetConst((grd_size_x - 1.0) / grd_size_x);
                C_GRD_U_BIAS = SetConst(0.5 / grd_size_x);
                C_GRD_V_SCALE = SetConst(grd_v_scale);
                C_GRD_V_BIAS = SetConst(0.5 / grd_size_y);

				int_dat grd_filter = If(oe2m_on, LINEAR_MIP_LINEAR, LINEAR_NO_MIP);
				S_GRD = SetTexture2D(grd_tex, grd_filter, WRAP, WRAP, FALSE);
				X_GRD_V = SetTexcoord("FLOAT");
			}

			if(nrm_primary_on | nrm_secondary_on | (cull == NONE)) { X_NRM_CS = SetTexcoord3("FLOAT"); }
			else
			{
				if(mid_even_on | mid_mip_on) { X_NRM_OUT = SetTexcoord3("FLOAT"); }
				else { X_NRM_MID_OUT = SetTexcoord4("FLOAT"); }
			}

            if(nrm_odd_primary_on)
            {
                Define("D_NRM_ODD_PRIMARY_SCALE_ON", 1);
                C_NRM_ODD_PRIMARY_SCALE = SetConst(nrm_odd_factor);
            }
            if(nrm_odd_secondary_on)
            {
                Define("D_NRM_ODD_SECONDARY_SCALE_ON", 1);
                C_NRM_ODD_SECONDARY_SCALE = SetConst(nrm_odd_factor);
            }
			if(nrm_odd_mesh_on) { Define("D_NRM_ODD_MESH_ON", 1); }
            if(nrm_even_primary_on)
            {
                Define("D_NRM_EVEN_PRIMARY_SCALE_ON", 1);
                C_NRM_EVEN_PRIMARY_SCALE = SetConst(nrm_even_factor);
            }
            if(nrm_even_secondary_on)
            {
                Define("D_NRM_EVEN_SECONDARY_SCALE_ON", 1);
                C_NRM_EVEN_SECONDARY_SCALE = SetConst(nrm_even_factor);
            }
			if(nrm_even_mesh_on) { Define("D_NRM_EVEN_MESH_ON", 1); }
            if(nrm_mip_primary_on)
            {
                Define("D_NRM_MIP_PRIMARY_SCALE_ON", 1);
                C_NRM_MIP_PRIMARY_SCALE = SetConst(nrm_mip_factor);
            }
            if(nrm_mip_secondary_on)
            {
                Define("D_NRM_MIP_SECONDARY_SCALE_ON", 1);
                C_NRM_MIP_SECONDARY_SCALE = SetConst(nrm_mip_factor);
            }
			if(nrm_mip_mesh_on) { Define("D_NRM_MIP_MESH_ON", 1); }

			if(nrm_tex_on)
			{
				X_TNG_CS = SetTexcoord3("FLOAT");
				X_BNR_CS = SetTexcoord3("FLOAT");
                C_NRM_SCALE = SetConst(1.0 / nrm_factor); //if nrm_factor is lower equal 0.0, this branch shoudld be disabled
				if(nrm_primary_on) { S_NRM_PRIMARY = SetTexture2D(nrm_primary_tex, LINEAR_MIP_LINEAR, tex_tile, tex_tile, FALSE); }
				if(nrm_secondary_on) { S_NRM_SECONDARY = SetTexture2D(nrm_secondary_tex, LINEAR_MIP_LINEAR, tex_tile, tex_tile, FALSE); }
			}
			if(idx_on)
			{
				int_dat idx_filter = If(idx_oe_on & idx_mip_on, LINEAR_MIP_LINEAR, LINEAR_NO_MIP);
				S_IDX = SetTexture2D(idx_tex, idx_filter, tex_tile, tex_tile, FALSE);
				if(idx_odd_on) { Define("IDX_ODD_CHANNEL", idx_odd_channel); }
				if(idx_even_on) { Define("IDX_EVEN_CHANNEL", idx_even_channel); }
				if(idx_mip_on) { Define("IDX_MIP_CHANNEL", idx_mip_channel); }
				if(hgt_on)
				{
					if(relief_on)
					{
						Define("D_RELIEF_ON", 1);
                        C_RELIEF_SCALE = SetConst( parallax_scale );
						Define("D_RELIEF_LINEAR_STEPS", relief_linear_steps);
						Define("D_RELIEF_BINARY_STEPS", relief_binary_steps);
                        C_RELIEF_STEPS_INV = SetConst( 1.0 / relief_linear_steps);
                        C_RELIEF_LINEAR_MIP = SetConst(relief_linear_mip);
                        C_RELIEF_BINARY_MIP = SetConst(relief_binary_mip);
					}
					else
					{
						Define("D_PARALLAX_ON", 1);
                        C_PARALLAX_SCALE = SetConst( -parallax_scale );
                        C_PARALLAX_BIAS = SetConst( parallax_scale );
                        C_PARALLAX_MIP = SetConst( parallax_mip );
					}
					X_CAM_DIR_TS = SetTexcoord3();
				}
			}

			float_dat env_mask_scale = 1.0 / (env_mask_max - env_mask_min);
			float_dat env_mask_bias = -env_mask_min * env_mask_scale;
			bool_dat env_on = ((env_mask_scale + env_mask_bias) > 0.0);
			if(env_on)
			{
                C_ENV_MASK_SCALE = SetConst(env_mask_scale);
                C_ENV_MASK_BIAS = SetConst(env_mask_bias);

				if(((env_tex != "") | (env_usermap >= 0)) & (max(env_fresnel_max, env_fresnel_min) > 0.0) & ((env_factor.x + env_factor.y + env_factor.z) > 0.0))
				{
					if(env_tex != "") { S_ENV = SetTextureCUBE(env_tex, LINEAR_NO_MIP, CLAMP, CLAMP, FALSE); }
					else { S_ENV = SetTextureCUBE(env_usermap, LINEAR_NO_MIP, CLAMP, CLAMP, FALSE); }

					bool_dat fresnel_on = (min(env_fresnel_max, env_fresnel_min) < 1.0) & (abs(env_fresnel_max - env_fresnel_min) > 0.0);

					bool_dat env_nrm_on = (nrm_tex_on & (env_nrm_scale > 0.0));

					if(fresnel_on | env_nrm_on)
					{
						X_POS_CS = SetTexcoord3("FLOAT");
                        if(env_nrm_on & (env_nrm_scale < 1.0))
                        {
                            Define("D_ENV_NRM_SCALE_ON", 1);
                            C_ENV_NRM_SCALE = SetConst(env_nrm_scale);
                        }
						if(fresnel_on)
						{
							float_dat env_fresnel_scale = 1.0 / (env_fresnel_max - env_fresnel_min);
							float_dat env_fresnel_bias = -env_fresnel_min * env_fresnel_scale;

                            Define("D_ENV_FRESNEL_SCALE_BIAS_ON", 1);
                            C_ENV_FRESNEL_SCALE = SetConst(env_fresnel_scale);
                            C_ENV_FRESNEL_BIAS = SetConst(env_fresnel_bias);
                            C_ENV_FRESNEL_POW = SetConst(If(env_fresnel_pow_on, 2.0, 1.0));
							if(!nrm_tex_on & (cull == CW)) { X_NRM_CS = SetTexcoord3("FLOAT"); }
						}
					}
					if(!env_nrm_on) { X_RFL_WS = SetTexcoord3("FLOAT"); }

                    C_ENV_FACTOR = SetConst(env_factor);
				}
			}

			// if(wind_bend_on) { Define("D_WIND_BEND_ON", 1);}

            if(!static_on)
            {
                MarkStencilDynamic();
            }

			VertexShader()
			{
				use Instancing();

				hlsl()
				{

					#include <master_new.hlsl>
					// #if defined(D_WIND_BEND_ON)
						// #include <wind.hlsl>
					// #endif

					void main()
					{
						#if defined(CLR_USR_ON)
							float4 usr_1;
							float4 usr_0 = Decode_Usr(I_CLR_USR, usr_1);
						#endif

						#if defined(X_GRD_V)
                            X_GRD_V = usr_0.w * C_GRD_V_SCALE + C_GRD_V_BIAS;
						#endif

						float4 pos_ms = Decode_Pos(I_POS_MS);

						float4 pos_ws = Mul_Pos(pos_ms, MODEL_XFORM_4x3);

						#if defined(X_O2E_HGT_MASK)
                            X_O2E_HGT_MASK = pos_ws.y * C_O2E_HGT_MASK_MUL + C_O2E_HGT_MASK_ADD;
						#endif
						#if defined(X_OE2M_HGT_MASK)
                            X_OE2M_HGT_MASK = pos_ws.y * C_OE2M_HGT_MASK_MUL + C_OE2M_HGT_MASK_ADD;
						#endif

						// #if defined(D_WIND_BEND_ON)
							// float3 pivot_ws = float3(MODEL_XFORM_4x3[0].w, MODEL_XFORM_4x3[1].w, MODEL_XFORM_4x3[2].w);
							// float3 pos2pivot_dir = pos_ws.xyz - pivot_ws;
							// float pos2pivot_distance = length(pos2pivot_dir);

							// float wind_power = GetWindDir_Power(pivot_ws, I_CLR_0.x);

							// float wind_mask = 0.0;

							// float3 wind_bend = GetWindDir_Force(wind_power);
							// pos2pivot_dir += wind_bend * I_CLR_0.y;
							// wind_mask = I_CLR_0.y;

 							// pos2pivot_dir += GetWindOmni(pos_ws.xyz) * wind_mask;

							// float3 pos2pivot_dir_n = normalize(pos2pivot_dir);

							// pos_ws.xyz = pos2pivot_dir_n * pos2pivot_distance + pivot_ws;
						// #endif


						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						#if defined(X_UV_0)
							X_UV_0 = Decode_UV(I_UV_0);
						#endif
						#if defined(X_UV_1)
							X_UV_1 = Decode_UV(I_UV_1);
						#endif
						#if defined(X_O2E_TEX_MASK_ADD)
                            X_O2E_TEX_MASK_ADD = usr_0.w * C_O2E_TEX_BIAS_SCALE + C_O2E_TEX_MASK_ADD;
						#endif
						#if defined(X_O2E_VC_MASK)
							float o2e_vc_mask = I_CLR_0.D_O2E_VC_CHANNEL;
                            #if defined(D_O2E_VC_BIAS_SCALE_ON)
                                o2e_vc_mask += usr_0.w * C_O2E_VC_BIAS_SCALE;
							#endif
                            X_O2E_VC_MASK = o2e_vc_mask * C_O2E_VC_MASK_MUL + C_O2E_VC_MASK_ADD;
						#endif
						#if defined(X_OE2M_TEX_MASK_ADD)
                            X_OE2M_TEX_MASK_ADD = usr_0.w * C_OE2M_TEX_BIAS_SCALE + C_OE2M_TEX_MASK_ADD;
						#endif
						#if defined(X_OE2M_VC_MASK)
							float oe2m_vc_mask = I_CLR_0.D_OE2M_VC_CHANNEL;
                            #if defined(D_OE2M_VC_BIAS_SCALE_ON)
                                oe2m_vc_mask += usr_0.w * C_OE2M_VC_BIAS_SCALE;
							#endif
                            X_OE2M_VC_MASK = oe2m_vc_mask * C_OE2M_VC_MASK_MUL + C_OE2M_VC_MASK_ADD;
						#endif

						float3 nrm_ws = Mul33(I_NRM_MS, MODEL_XFORM_4x3);
						float3 nrm_cs = Mul33(nrm_ws, VIEW_XFORM);
						float3 nrm_n_cs = normalize(nrm_cs);

						#if defined(X_NRM_MID_OUT)
							X_NRM_MID_OUT.xyz = nrm_n_cs * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5)
                            X_NRM_MID_OUT.w = C_MID_ODD;
X_NRM_MID_OUT.w = 1.0;
						#elif defined(X_NRM_OUT)
							X_NRM_OUT = nrm_n_cs * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5);
						#endif

						#if defined(X_NRM_CS)
							X_NRM_CS = nrm_n_cs;
						#endif

						#if defined(X_O2E_DIR_MASK)
							float o2e_dir_mask = dot(nrm_n_cs, C_O2E_DIR_N_CS);
                            X_O2E_DIR_MASK = saturate(o2e_dir_mask * C_O2E_DIR_MASK_MUL + C_O2E_DIR_MASK_ADD);
						#endif

						#if defined(X_OE2M_DIR_MASK)
							float oe2m_dir_mask = dot(nrm_n_cs, C_OE2M_DIR_N_CS);
                            X_OE2M_DIR_MASK = saturate(oe2m_dir_mask * C_OE2M_DIR_MASK_MUL + C_OE2M_DIR_MASK_ADD);
						#endif

						#if defined(TNG_ON)
							float3 tng_ws = Mul33(I_TNG_MS.xyz, MODEL_XFORM_4x3);
						#endif

						#if defined(X_TNG_CS)
							float3 tng_cs = Mul33(tng_ws, VIEW_XFORM);
							float3 tng_n_cs = normalize(tng_cs);
							X_TNG_CS = tng_n_cs;

							float3 bnr_n_cs = cross(nrm_n_cs, tng_n_cs);
							bnr_n_cs *= I_TNG_MS.w;
							X_BNR_CS = bnr_n_cs;
						#endif

						float3 cam_dir_ws = pos_ws.xyz - CAMERA_POS_WS.xyz;

						#if defined(X_CAM_DIR_TS)
							float3 w2t_xform[3];
							w2t_xform[0] = tng_ws;
							w2t_xform[1] = cross(nrm_ws, tng_ws) * I_TNG_MS.w;
							w2t_xform[2] = nrm_ws;

							X_CAM_DIR_TS = Mul33(cam_dir_ws, w2t_xform);
						#endif


						#if defined(S_ENV)
							#if defined(X_RFL_WS)
								float3 nrm_n_ws = normalize(nrm_ws);
								X_RFL_WS = reflect(cam_dir_ws, nrm_n_ws);
							#endif

							#if defined(X_POS_CS)
								X_POS_CS = Mul_Pos(pos_ws, VIEW_XFORM).xyz;
							#endif
						#endif


					}
				}
			}

			PixelShader()
			{
				hlsl()
				{
					#if defined(SHADER_PATH_ORBIS)
						// #pragma PSSL_target_output_format (target 1 FMT_UNORM16_ABGR)
					#endif


					#include <master_new.hlsl>
					#include <depth_sample.hlsl>

					#if defined(S_IDX)
						FLOAT MixIDX(FLOAT4 idxs, FLOAT o2e, FLOAT oe2m)
						{
							#if defined(IDX_ODD_CHANNEL) || defined(IDX_EVEN_CHANNEL)
								#if defined(IDX_ODD_CHANNEL) && defined(IDX_EVEN_CHANNEL)
									FLOAT idx = lerp(idxs.IDX_ODD_CHANNEL, idxs.IDX_EVEN_CHANNEL, o2e);
								#elif defined(IDX_ODD_CHANNEL)
									FLOAT idx = idxs.IDX_ODD_CHANNEL;
								#elif defined(IDX_EVEN_CHANNEL)
									FLOAT idx = idxs.IDX_EVEN_CHANNEL;
								#endif
								#if defined(IDX_MIP_CHANNEL)
									idx = lerp(idx, idxs.IDX_MIP_CHANNEL, oe2m);
								#endif
							#elif defined(IDX_MIP_CHANNEL)
								FLOAT idx = idxs.IDX_MIP_CHANNEL;
							#endif
							return idx;
						}
						FLOAT SampleIDX(FLOAT2 uv, FLOAT o2e, FLOAT oe2m, FLOAT mip)
						{
							FLOAT4 idxs = Sample(S_IDX, uv, mip);
							return MixIDX(idxs, o2e, oe2m);
						}
						FLOAT SampleIDX(FLOAT2 uv, FLOAT o2e, FLOAT oe2m)
						{
							FLOAT4 idxs = Sample(S_IDX, uv);
							return MixIDX(idxs, o2e, oe2m);
						}
					#endif

					void main()
					{
						#if defined(S_GRD_MAP)
							FLOAT4 grd_map = Sample(S_GRD_MAP, X_UV_1);
						#endif

						FLOAT o2e = 0.0;
						#if defined(D_O2E_OP)
							FLOAT o2e_wo_dir = D_O2E_INIT;
							#if defined(D_O2E_TEX_CHANNEL)
								#if defined(X_O2E_TEX_MASK_ADD)
									FLOAT o2e_tex_mask_add = X_O2E_TEX_MASK_ADD;
								#else
                                    FLOAT o2e_tex_mask_add = C_O2E_TEX_MASK_ADD;
								#endif
                                o2e_wo_dir = saturate(grd_map.D_O2E_TEX_CHANNEL * C_O2E_TEX_MASK_MUL + o2e_tex_mask_add);
							#endif
							#if defined(X_O2E_VC_MASK)
								o2e_wo_dir = o2e_wo_dir D_O2E_OP saturate(X_O2E_VC_MASK);
							#endif
							#if defined(X_O2E_HGT_MASK)
								o2e_wo_dir = o2e_wo_dir D_O2E_OP saturate(X_O2E_HGT_MASK);
							#endif
							#if defined(X_O2E_DIR_MASK)
								o2e = o2e_wo_dir D_O2E_OP (X_O2E_DIR_MASK * X_O2E_DIR_MASK);
							#else
								o2e = o2e_wo_dir;
							#endif
							o2e = saturate(o2e);
						#endif

						FLOAT oe2m = 0.0;
						#if defined(D_OE2M_OP)
							FLOAT oe2m_wo_dir = D_OE2M_INIT;
							#if defined(D_OE2M_TEX_CHANNEL)
								#if defined(X_OE2M_TEX_MASK_ADD)
									FLOAT oe2m_tex_mask_add = X_OE2M_TEX_MASK_ADD;
								#else
                                    FLOAT oe2m_tex_mask_add = C_OE2M_TEX_MASK_ADD;
								#endif
                                oe2m_wo_dir = saturate(grd_map.D_OE2M_TEX_CHANNEL * C_OE2M_TEX_MASK_MUL + oe2m_tex_mask_add);
							#endif
							#if defined(X_OE2M_VC_MASK)
								oe2m_wo_dir = oe2m_wo_dir D_OE2M_OP saturate(X_OE2M_VC_MASK);
							#endif
							#if defined(X_OE2M_HGT_MASK)
								oe2m_wo_dir = oe2m_wo_dir D_OE2M_OP saturate(X_OE2M_HGT_MASK);
							#endif
							#if defined(X_OE2M_DIR_MASK)
								oe2m = oe2m_wo_dir D_OE2M_OP (X_OE2M_DIR_MASK * X_OE2M_DIR_MASK);
							#else
								oe2m = oe2m_wo_dir;
							#endif
							oe2m = saturate(oe2m);
						#endif

						#if defined(X_UV_0)
							FLOAT2 uv_0 = X_UV_0;
						#endif

						#if defined(D_PARALLAX_ON) || defined(D_RELIEF_ON)
							FLOAT3 cam_dir_n_ts = normalize(X_CAM_DIR_TS);

							#if defined(D_PARALLAX_ON)
								FLOAT hgt = SampleIDX(uv_0, o2e, oe2m, C_PARALLAX_MIP);
								hgt = hgt * C_PARALLAX_SCALE + C_PARALLAX_BIAS; //scale and inv
								uv_0 += cam_dir_n_ts.xy * hgt;
							#elif defined(D_RELIEF_ON)

                                // cam_dir_n_ts *= C_RELIEF_SCALE;
                                // FLOAT step_size_current = C_RELIEF_STEPS_INV;
								// FLOAT depth_current = 0.0;

								// for(int i=0; i<D_RELIEF_LINEAR_STEPS; i++)
								// {
									// float2 uv_lin = uv_0 + cam_dir_n_ts.xy * depth_current;
                                    // float depth_sample = 1.0 - SampleIDX(uv_lin, o2e, oe2m, C_RELIEF_LINEAR_MIP);
									// depth_current += (depth_current < depth_sample) ? step_size_current : 0.0;
								// }

								// for(int i=0; i<D_RELIEF_BINARY_STEPS; i++)
								// {
									// step_size_current *= 0.5;
									// float2 uv_bin = uv_0 + cam_dir_n_ts.xy * depth_current;
                                    // float depth_sample = 1.0 - SampleIDX(uv_bin, o2e, oe2m, C_RELIEF_BINARY_MIP);
									// depth_current += (depth_current<depth_sample) ? 2.0 * step_size_current : 0.0;
									// depth_current -= step_size_current;
								// }
								// uv_0 += cam_dir_n_ts.xy * depth_current;



								float3 current = float3(uv_0, 1.0);
								float3 offset_step = cam_dir_n_ts * C_RELIEF_STEPS_INV;
								offset_step.xy *= C_RELIEF_SCALE;
								offset_step.z = -C_RELIEF_STEPS_INV;

								for(int i=0; i<D_RELIEF_LINEAR_STEPS; i++)
								{
                                    float depth_sample = SampleIDX(current.xy, o2e, oe2m, C_RELIEF_LINEAR_MIP);
									float3 current_step = (current.z > depth_sample) ? offset_step : float3(0.0, 0.0, 0.0);
									current += current_step;
								}

								for(int i=0; i<D_RELIEF_BINARY_STEPS; i++)
								{
                                    float depth_sample = SampleIDX(current.xy, o2e, oe2m, C_RELIEF_LINEAR_MIP);
									offset_step *= 0.5;
									float3 current_step = (current.z > depth_sample) ? offset_step : -offset_step;
									current += current_step;
								}
								uv_0 = current.xy;



								// float3 current = float3(uv_0, 1.0);
                                // float3 offset_step = cam_dir_n_ts * float3(C_RELIEF_STEPS_INV * C_RELIEF_SCALE, C_RELIEF_STEPS_INV * C_RELIEF_SCALE, C_RELIEF_STEPS_INV);

								// for(int i=0; i<D_RELIEF_LINEAR_STEPS; i++)
								// {
                                    // float depth_sample = SampleIDX(current.xy, o2e, oe2m, C_RELIEF_LINEAR_MIP);
									// float3 current_step = (current.z > depth_sample) ? offset_step : float3(0.0, 0.0, 0.0);
									// current += current_step;
								// }

								// for(int i=0; i<D_RELIEF_BINARY_STEPS; i++)
								// {
                                    // float depth_sample = SampleIDX(current.xy, o2e, oe2m, C_RELIEF_LINEAR_MIP);
									// offset_step *= 0.5;
									// float3 current_step = (current.z > depth_sample) ? offset_step : -offset_step;
									// current += current_step;
								// }
								// uv_0 = current.xy;
							#endif
						#endif

						// #if defined(D_CLIP_ON)
							// clip(clr_0.w - 0.25);
						// #endif

						#if defined(X_NRM_MID_OUT)
							O_NRM = X_NRM_MID_OUT;
						#elif defined(X_NRM_OUT)
							O_NRM.xyz = X_NRM_OUT;
						#else
							#if defined(S_NRM_PRIMARY) || defined(S_NRM_SECONDARY)
								FLOAT4 nrms_ts = float4(0.0, 0.0, 0.0, 0.0);
                                FLOAT3 nrm_ts = FLOAT3(0.0, 0.0, C_NRM_SCALE);
								#if defined(S_NRM_PRIMARY)
									nrms_ts.xy = Sample(S_NRM_PRIMARY, uv_0).ag * 2.0 - 1.0;
								#endif
								#if defined(S_NRM_SECONDARY)
									nrms_ts.zw = Sample(S_NRM_SECONDARY, uv_0).ag * 2.0 - 1.0;
								#endif

                                #if defined(D_NRM_ODD_PRIMARY_SCALE_ON)
                                    nrm_ts.xy = nrms_ts.xy * C_NRM_ODD_PRIMARY_SCALE;
                                #elif defined(D_NRM_ODD_SECONDARY_SCALE_ON)
                                    nrm_ts.xy = nrms_ts.zw * C_NRM_ODD_SECONDARY_SCALE;
								#endif

                                #if defined(D_NRM_EVEN_PRIMARY_SCALE_ON)
                                    nrm_ts.xy = lerp(nrm_ts.xy, nrms_ts.xy * C_NRM_EVEN_PRIMARY_SCALE, o2e);
                                #elif defined(D_NRM_EVEN_SECONDARY_SCALE_ON)
                                    nrm_ts.xy = lerp(nrm_ts.xy, nrms_ts.zw * C_NRM_EVEN_SECONDARY_SCALE, o2e);
								#elif defined(D_NRM_MIP_MESH_ON)
									nrm_ts.xy = lerp(nrm_ts.xy, float2(0.0, 0.0), o2e);
								#endif

                                #if defined(D_NRM_MIP_PRIMARY_SCALE_ON)
                                    nrm_ts.xy = lerp(nrm_ts.xy, nrms_ts.xy * C_NRM_MIP_PRIMARY_SCALE, oe2m);
                                #elif defined(D_NRM_MIP_SECONDARY_SCALE_ON)
                                    nrm_ts.xy = lerp(nrm_ts.xy, nrms_ts.zw * C_NRM_MIP_SECONDARY_SCALE, oe2m);
								#elif defined(D_NRM_MIP_MESH_ON)
									nrm_ts.xy = lerp(nrm_ts.xy, float2(0.0, 0.0), oe2m);
								#endif

								float3 E2T_XFORM[3];
								E2T_XFORM[0] = X_TNG_CS;
								E2T_XFORM[1] = X_BNR_CS;
								E2T_XFORM[2] = X_NRM_CS;

								FLOAT3 nrm_cs = Mul33T(nrm_ts, E2T_XFORM);
								FLOAT3 nrm_n_cs = normalize(nrm_cs);
								#if defined(D_O2E_OP) && defined(D_O2E_DIR_ON)
									FLOAT o2e_dir_mask = dot(nrm_n_cs, C_O2E_DIR_N_CS);
                                    o2e_dir_mask = saturate(o2e_dir_mask * C_O2E_DIR_MASK_MUL + C_O2E_DIR_MASK_ADD);
									o2e = saturate(o2e_wo_dir D_O2E_OP o2e_dir_mask);
								#endif
								#if defined(D_OE2M_OP) && defined(D_OE2M_DIR_ON)
									FLOAT oe2m_dir_mask = dot(nrm_n_cs, C_OE2M_DIR_N_CS);
                                    oe2m_dir_mask = saturate(oe2m_dir_mask * C_OE2M_DIR_MASK_MUL + C_OE2M_DIR_MASK_ADD);
									oe2m = saturate(oe2m_wo_dir D_OE2M_OP oe2m_dir_mask);
								#endif
							#else
								FLOAT3 nrm_n_cs = X_NRM_CS; //isn't normalized
							#endif

							#if defined(D_CULLING_NONE)
								nrm_n_cs = I_SIDE ? nrm_n_cs : -nrm_n_cs;
							#endif
							#if defined(D_NRM_FACTORS)
								O_NRM = nrm_n_cs.xyzx * D_NRM_FACTORS.xxxy + D_NRM_FACTORS.xxxz;
							#else
								O_NRM.xyz = nrm_n_cs * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5);
							#endif
						#endif

                        O_NRM.w = C_MID_ODD;
O_NRM.w = C_MID_GLOBAL;
O_NRM.w = 1.0;
                        // #if defined(D_MID_EVEN_ON)
                            // O_NRM.w = (o2e > C_O2E_MID_THRESHOLD) ? C_MID_EVEN : O_NRM.w;
						// #endif
                        // #if defined(D_MID_MIP_ON)
                            // O_NRM.w = (oe2m > C_OE2M_MID_THRESHOLD) ? C_MID_MIP : O_NRM.w;
						// #endif

						#if defined(S_GRD)
							FLOAT grd_u = SampleIDX(uv_0, o2e, oe2m);
                            grd_u = grd_u * C_GRD_U_SCALE + C_GRD_U_BIAS;
                            FLOAT grd_v = X_GRD_V + lerp(o2e, 0.5, oe2m) * C_GRD_MAP_V_SCALE;
							O_DIF = Sample(S_GRD, FLOAT2(grd_u, grd_v), oe2m);
						#else
							O_DIF = 1.0;
						#endif

						#if defined(S_ENV)
							FLOAT3 rfl_mask = SwizzleXXX( saturate(O_DIF.w * C_ENV_MASK_SCALE + C_ENV_MASK_BIAS) );
							#if defined(S_ENV)
								#if defined(X_POS_CS)
									#if defined(S_NRM_PRIMARY) || defined(S_NRM_SECONDARY)
										FLOAT3 nrm_n_cs_4_rfl = nrm_n_cs;
                                        #if defined(D_ENV_NRM_SCALE_ON)
                                            nrm_n_cs_4_rfl = lerp(X_NRM_CS.xyz, nrm_n_cs_4_rfl, C_ENV_NRM_SCALE);
											nrm_n_cs_4_rfl = normalize(nrm_n_cs_4_rfl);
										#endif
									#else
										FLOAT3 nrm_n_cs_4_rfl = normalize(X_NRM_CS);
									#endif

                                    #if defined(D_ENV_FRESNEL_SCALE_BIAS_ON)
										FLOAT3 cam_dir_n = normalize(X_POS_CS);
										FLOAT fresnel = saturate(1.0 - dot(-nrm_n_cs_4_rfl, cam_dir_n));
                                        fresnel = saturate(fresnel * C_ENV_FRESNEL_SCALE + C_ENV_FRESNEL_BIAS);
                                        fresnel = pow(fresnel, C_ENV_FRESNEL_POW);
									#endif
								#endif

								#if defined(X_RFL_WS)
									FLOAT3 rfl_ws = X_RFL_WS;
								#else
									FLOAT3 rfl_cs = reflect(X_POS_CS, nrm_n_cs_4_rfl);
									FLOAT3 rfl_ws = Mul33(rfl_cs, INVVIEW_XFORM);
								#endif

								FLOAT3 v_env = SampleCUBE_h3(S_ENV, rfl_ws, 0.0);
                                v_env *= C_ENV_FACTOR;
								FLOAT3 env_mask = rfl_mask;

                                #if defined(D_ENV_FRESNEL_SCALE_BIAS_ON)
									env_mask *= fresnel;
								#endif

								O_DIF.xyz = lerp(O_DIF.xyz, v_env, env_mask);
							#endif
						#endif
						
						O_SPC.xyz = SwizzleXXX(0.0);
						O_SPC.w = O_DIF.w;
					}
				}
			}
		}
		if(cast_shadows_on | zpass_on)
		{
			att_standard shadow_params = new att_standard();

			shadow_params.clr_0_tex = If(texkill_on, idx_tex, "");
			shadow_params.tex_tile = tex_tile;
			// shadow_params.wind_bend_on = wind_bend_on;

			depth_pass dpt = new depth_pass(this);

			if(cast_shadows_on)
			{
				shadow_params.technique = "zfill";
				dpt.setup(shadow_params);
			}
			if(zpass_on)
			{
				shadow_params.technique = "dpt";
				dpt.setup(shadow_params);
			}
		}
		// if(highlight_on)
		// {
			// highlight_a highlight = new highlight_a(this);
			// highlight.setup(in_params);
		// }
	}
}
