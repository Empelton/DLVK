//new

using engineflags;
using settemplates;
using tmu;

template
{
	category Main
	{
		float_dat width = 0.02 : display(Line width [m]);
	}
	category Advanced
	{
		float_dat max_px_screen = 4.0 : display(Maximum pixels on screen);
		float_dat min_px_screen = 1.0 : display(Minimum pixels on screen);
	}

    templatebody()
    {
		tech("trn_back")
        {
			Cull(NONE);
			DepthFunc(LEQUAL, FALSE);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, ZERO, ONE);
			BlendFunc(SRC_ALPHA, INV_SRC_ALPHA, ZERO, ONE, 1);

			Input I_POS_MS = new InputFloat4("POSITION");
			Input I_UV_0 = new InputFloat2("TEXCOORD0");
			Input I_TNG_MS = new InputFloat4("TANGENT0");
			Input I_NRM_MS = new InputFloat3("NORMAL0");

			Output O_RT0 = new OutputFLOAT4("COLOR0");
			Output O_RT1 = new OutputFLOAT4("COLOR1");

			X_CLR = SetTexcoord3();
			X_MASK = SetTexcoord();
			X_OPACITY = SetTexcoord();

			float_dat px_scale = 1.0 / (max_px_screen - min_px_screen);
			float_dat px_bias = -min_px_screen * px_scale;

            C_WIDTH = SetConst(width);

            C_OPACITY_SCALE = SetConst(px_scale);
            C_OPACITY_BIAS = SetConst(px_bias);

			extern vec3_dat v_pp_sun_scattering_dir;
			C_SUN_SCATTERING_DIR = SetConst(v_pp_sun_scattering_dir);

			VertexShader()
			{
				use Instancing();

				hlsl()
				{
					#include <master_new.hlsl>
					#include <fog.hlsl>

					void main()
					{
						I_POS_MS = Decode_Pos(I_POS_MS);
						float4 pos_ws = Mul_Pos(I_POS_MS, MODEL_XFORM_4x3);

						float3 cam_dir_ws = pos_ws.xyz - CAMERA_POS_WS.xyz;

						float cam_dir_length = length(cam_dir_ws);

						I_UV_0 = Decode_UV(I_UV_0);

						float3 bnr_ms = cross(I_NRM_MS, I_TNG_MS.xyz);
						float3 nrm = (I_UV_0.y > 0.5) ? -bnr_ms : bnr_ms;

						float4 pos_cs = Mul_Pos(pos_ws, VIEW_XFORM);
						float4 pos_cs_1 = pos_cs + FLOAT4(0.0, C_WIDTH, 0.0, 0.0);
						
						float4 pos_ss_0 = Pos_Out_CS(pos_cs);
						float4 pos_ss_1 = Pos_Out_CS(pos_cs_1);

						pos_ss_0.xy = pos_ss_0.xy / pos_ss_0.w * 0.5 + 0.5;
						pos_ss_1.xy = pos_ss_1.xy / pos_ss_1.w * 0.5 + 0.5;

						float pos_ss_dist = length( (pos_ss_1.xy - pos_ss_0.xy) * RENDER_TARGET_PARAMS.zw );

                        nrm *= (C_WIDTH * 0.25);
                        nrm /= saturate(pos_ss_dist * C_OPACITY_SCALE);

						I_POS_MS.xyz += nrm.xyz;

						pos_ws = Mul_Pos(I_POS_MS, MODEL_XFORM_4x3);
						V_POS_OUT_TC = Pos_Out_WS(pos_ws);

						X_MASK = I_UV_0.y * 2.0 - 1.0;


						X_CLR = Scattering(normalize(-cam_dir_ws), C_SUN_SCATTERING_DIR, cam_dir_length);

                        X_OPACITY = saturate(pos_ss_dist * C_OPACITY_SCALE + C_OPACITY_BIAS);

					}
				}

			}

			PixelShader()
			{
				hlsl()
				{

					#include <master_new.hlsl>
					#include <fog.hlsl>

					void main()
					{
						O_RT0.xyz = X_CLR;
						FLOAT mask = saturate(1.0 - X_MASK * X_MASK);
						O_RT0.w = saturate(mask * X_OPACITY);
						O_RT1 = O_RT0;
					}
				}
			}
        }
    }
}


